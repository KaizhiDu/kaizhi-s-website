{
  "5dd9cdb581ca03e15c7df20c": "# Spring Container\n\n## Inversion of Control\n\nIOC means giving your designed objects to the spring container control instead of the traditional direct control inside your object.\n\n## Dependency Injection\n\nDependency : dependent spring container.\n\nInjection: The spring container injects the required object\n\n# Basic useful annotation\n\n## @Qualifier\n\n@Qualifier: If tow class implements one interface, we need to use qualifier to distinguish them.\n\n```java\n\t@Autowired\n    @Qualifier(\"happyFortune\")\n    private HappyFortune happyFortune;\n\n    @Autowired\n    @Qualifier(\"randomFortune\")\n    private RandomFortune randomFortune;\n```\n\n## @PostConstruct\n\n@PostConstruct: define initial method, only execute once.\n\n```java\n@PostConstruct\n    public void doMyStartupStuff() {\n        System.out.println(\"we call the init method\");\n    }\n```\n\n## @InitBinder\n\n@InitBinder: pre-process all web requests coming into this Controller\n\n```java\n@InitBinder\n    // add an initbinder to convert trim input string\n    public void initBinder(WebDataBinder dataBinder) {\n        StringTrimmerEditor stringTrimmerEditor = new StringTrimmerEditor(true);\n        dataBinder.registerCustomEditor(String.class, stringTrimmerEditor);\n    }\n```\n\n# Validation\n\n## Annotation from spring\n\n```java\n@NotNull(message = \"firstName is required\")\n    @Size(min = 1, message = \"size must >1\")\n    private String firstName;\n```\n\n## Customize annotation\n\n```java\n@CourseCode\n    private String courseCode;\n```\n\n```java\n@Constraint(validatedBy =  CourseCodeConstrainValidator.class)\n//where are we use this annotation\n@Target( { ElementType.METHOD, ElementType.FIELD})\n//Retain this annotation in the java class file\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface CourseCode {\n    // define default course code\n    public String value() default \"LUV\";\n    // define default error message\n    public String message() default \"must start with LUV\";\n    // define default groups\n    public Class<?>[] groups() default {};\n    // define default payload\n    public Class<? extends Payload>[] payload() default {};\n\n}\n```\n\n```java\npublic class CourseCodeConstrainValidator implements ConstraintValidator<CourseCode, String>{\n    private String coursePrefix;\n    @Override\n    public void initialize(CourseCode theCourseCode) {\n        coursePrefix = theCourseCode.value();\n    }\n    @Override\n    //SpringMVC will call is Valid\n    public boolean isValid(String theCode, ConstraintValidatorContext constraintValidatorContext) {\n        boolean result;\n        if (theCode != null) result = theCode.startsWith(coursePrefix);\n        else result = true;\n        return result;\n    }\n}\n```\n\n",
  "5dd9cf56c3cf5851159c5a50": "# Hibernate\n\n## Basic method\n\n***fetch = FetchType.LAZY***   lazy loading, when loading an entity, properties that define lazy loading will not load from the database right away.\n\n***fetch = FetchType.EAGER*** eager loading, when an entity is loaded, the property that defines the rush loading will be loaded immediately from the database.\n\n***cascade = CascadeType.ALL*** refers to a cascading relationship, any operation will affect the corresponding cascading.\n\n## OneToOne\n\n\u200B\tStudent and Course's relationship is OneToOne\n\n```java\n//Student\n@OneToOne(cascade = CascadeType.ALL)\n    //Foreign key name in database\n    @JoinColumn(name = \"course_id\")\n    private Course course;\n```\n\n```java\n//Course\n//mappedBy refers to property course in Student class\n    @OneToOne(mappedBy = \"course\", cascade = CascadeType.ALL)\n    private Student student;\n```\n\n## OneToMany\n\n\u200B\tStudent and hobby's relationship is OneToMany\n\n```java\n//Student\n//we do not want to add the delete rule in the cascade\n    @OneToMany(fetch = FetchType.LAZY, mappedBy = \"student\", cascade = {CascadeType.PERSIST, CascadeType.REFRESH, CascadeType.MERGE, CascadeType.DETACH})\n    private List<Hobby> hobbies;\n```\n\n```java\n//Hobby\n//we do not want to add the delete rule in the cascade\n    @ManyToOne(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST, CascadeType.REFRESH, CascadeType.MERGE, CascadeType.DETACH})\n    @JoinColumn(name = \"student_id\")\n    private Student student;\n```\n\n## ManyToMany\n\n\u200B\tTeacher and course's relationship is ManyToMany\n\n```java\n//Teacher\n@ManyToMany(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST, CascadeType.REFRESH, CascadeType.MERGE, CascadeType.DETACH})\n@JoinTable(\n        name = \"teacher_course\",\n        joinColumns = @JoinColumn(name = \"teacher_id\"),\n        inverseJoinColumns = @JoinColumn(name = \"course_id\")\n)\nprivate List<Course> courses;\n```\n\n```java\n//Course\n@ManyToMany(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST, CascadeType.REFRESH, CascadeType.MERGE, CascadeType.DETACH})\n@JoinTable(\n        name = \"teacher_course\",\n        joinColumns = @JoinColumn(name = \"course_id\"),\n        inverseJoinColumns = @JoinColumn(name = \"teacher_id\")\n)\nprivate List<Teacher> teachers;\n```\n\n",
  "5dd9f5be538cba7031094498": "# Hibernate\n\n## Basic method\n\n***fetch = FetchType.LAZY***   lazy loading, when loading an entity, properties that define lazy loading will not load from the database right away.\n\n***fetch = FetchType.EAGER*** eager loading, when an entity is loaded, the property that defines the rush loading will be loaded immediately from the database.\n\n***cascade = CascadeType.ALL*** refers to a cascading relationship, any operation will affect the corresponding cascading.\n\n## OneToOne\n\n\u200B\tStudent and Course's relationship is OneToOne\n\n```java\n//Student\n@OneToOne(cascade = CascadeType.ALL)\n    //Foreign key name in database\n    @JoinColumn(name = \"course_id\")\n    private Course course;\n```\n\n```java\n//Course\n//mappedBy refers to property course in Student class\n    @OneToOne(mappedBy = \"course\", cascade = CascadeType.ALL)\n    private Student student;\n```\n\n## OneToMany\n\n\u200B\tStudent and hobby's relationship is OneToMany\n\n```java\n//Student\n//we do not want to add the delete rule in the cascade\n    @OneToMany(fetch = FetchType.LAZY, mappedBy = \"student\", cascade = {CascadeType.PERSIST, CascadeType.REFRESH, CascadeType.MERGE, CascadeType.DETACH})\n    private List<Hobby> hobbies;\n```\n\n```java\n//Hobby\n//we do not want to add the delete rule in the cascade\n    @ManyToOne(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST, CascadeType.REFRESH, CascadeType.MERGE, CascadeType.DETACH})\n    @JoinColumn(name = \"student_id\")\n    private Student student;\n```\n\n## ManyToMany\n\n\u200B\tTeacher and course's relationship is ManyToMany\n\n```java\n//Teacher\n@ManyToMany(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST, CascadeType.REFRESH, CascadeType.MERGE, CascadeType.DETACH})\n@JoinTable(\n        name = \"teacher_course\",\n        joinColumns = @JoinColumn(name = \"teacher_id\"),\n        inverseJoinColumns = @JoinColumn(name = \"course_id\")\n)\nprivate List<Course> courses;\n```\n\n```java\n//Course\n@ManyToMany(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST, CascadeType.REFRESH, CascadeType.MERGE, CascadeType.DETACH})\n@JoinTable(\n        name = \"teacher_course\",\n        joinColumns = @JoinColumn(name = \"course_id\"),\n        inverseJoinColumns = @JoinColumn(name = \"teacher_id\")\n)\nprivate List<Teacher> teachers;\n```\n\n\n\n# AOP\n\n## @Pointcut\n\n\u200B\t@PointCut is a set of one or more JoinPoint where an advice should be executed. \n\n```java\n@Pointcut(\"execution(* com.kevin.dao.*.*(..))\")\npublic void daoPackage() {}\n\n@Pointcut(\"execution(* com.kevin.dao.*.get*(..))\")\npublic void getter() {}\n\n@Pointcut(\"execution(* com.kevin.dao.*.set*(..))\")\npublic void setter() {}\n\n@Pointcut(\"daoPackage() && !(getter() || setter())\")\npublic void forDaoPackageNoGetterSetter() {}\n```\n\n## @Before @After  \n\n```java\n@Before(\"com.kevin.aspect.AopExpression.forDaoPackageNoGetterSetter()\")\npublic void beforeDAO(JoinPoint joinPoint) {\n    System.out.println(\"\\n=========>>>>>  Now we run the before\");\n\n    // display the method signature\n    MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();\n\n    System.out.println(\"Method: \" +methodSignature);\n\n    // display method arguments\n    Object[] args = joinPoint.getArgs();\n    for (Object tempArg : args) {\n        if (tempArg instanceof Account) {\n            // downcast and print Account specific stuff\n            Account account = (Account) tempArg;\n            System.out.println(\"account name: \"+account.getName());\n            System.out.println(\"account level: \"+account.getLevel());\n\n        }\n    }\n}\n```\n\n## @AfterReturning\n\n```java\n@AfterReturning(\n        pointcut = \"execution(* com.kevin.dao.AccountDAO.findAccounts(..))\",\n        returning = \"result\")\npublic void afterReturningFindAccountsAdvice(JoinPoint joinPoint, List<Account> result){\n    // print out which method we are advising on\n    String method = joinPoint.getSignature().toShortString();\n    System.out.println(\"\\n =======>>> @AfterReturning \" + method);\n    // print out the result of the method call\n    System.out.println(\"result is: \" + result);\n\n    // let's post-process the data ...Let's modify it\n\n    // convert the account names to uppercase\n\n    convertAccountNamesToUppercase(result);\n\n    System.out.println(\"result(Uppercase) is: \" + result);\n\n}\n\nprivate void convertAccountNamesToUppercase(List<Account> result) {\n        // loop through accounts\n        for (Account account : result ) {\n        // get uppercase version of name\n        String upperName = account.getName().toUpperCase();\n        // update the name on the account\n            account.setName(upperName);\n        }\n    }\n```\n\n## @AfterThrowing\n\n```java\n@AfterThrowing(\n            pointcut = \"execution(* com.kevin.dao.AccountDAO.findAccounts(..))\",\n            throwing = \"e\")\n    public void afterThrowingFindAccountsAdvice(JoinPoint joinPoint, Throwable e) {\n        // print out which method we are advising on\n        String method = joinPoint.getSignature().toShortString();\n        System.out.println(\"\\n =======>>> @AfterThrowing \" + method);\n\n        // log the exception\n        System.out.println(\"\\n Exception is \" + e);\n    }\n```\n\n## @ExceptionHandler\n\nSometime we need to return a JSON data instead of error page, when the error happen. So we need to use the ExceptionHandler.\n\n```JAVA\n// If we want to use the ExceptionHandler, we need to use @ControllerAdvice\n@ControllerAdvice\npublic class StudentRestExceptionHandler {\n\n    // Add an exception handler using @ExceptionHandler\n    @ExceptionHandler\n    public ResponseEntity<StudentErrorResponse> handleException(StudentNotFoundException e) {\n        // create a StudentErrorResponse\n        StudentErrorResponse error = new StudentErrorResponse();\n        error.setStatus(HttpStatus.NOT_FOUND.value());\n        error.setMessage(e.getMessage());\n        error.setTimeStamp(System.currentTimeMillis());\n\n        // return ResponseEntity\n        return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);\n    }\n\n    // add another exception handler\n    @ExceptionHandler\n    public ResponseEntity<StudentErrorResponse> handleException2(Exception e) {\n\n        // create a StudentErrorResponse\n        StudentErrorResponse error = new StudentErrorResponse();\n        error.setStatus(HttpStatus.BAD_REQUEST.value());\n        error.setMessage(e.getMessage());\n        error.setTimeStamp(System.currentTimeMillis());\n\n        // return ResponseEntity\n        return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST);\n    }\n}\n```\n\n```java\n// 404 \npublic class StudentNotFoundException extends RuntimeException{\n\n    public StudentNotFoundException(String message) {\n        super(message);\n    }\n\n    public StudentNotFoundException(String message, Throwable cause) {\n        super(message, cause);\n    }\n\n    public StudentNotFoundException(Throwable cause) {\n        super(cause);\n    }\n}\n```\n\n```java\n// status javaBean\npublic class StudentErrorResponse {\n    private int status;\n    private long timeStamp;\n    private String message;\n}\n```\n\n```java\n@GetMapping(\"/student/{studentId}\")\npublic Student getStudent(@PathVariable int studentId) {\n\n    // check the studentId against list size\n    if ((studentId >= students.size()) || (studentId < 0) ){\n        throw new StudentNotFoundException(\"StudentId is not found \"+studentId);\n    }\n\n    return students.get(studentId);\n}\n```\n\n## @Around\n\n```java\n@Around(\"execution(* com.kevin.service.TrafficFortuneService.getFurtune(..))\")\npublic Object aroundGetFortune(ProceedingJoinPoint proceedingJoinPoint) throws Throwable{\n\n    // print out method we are advising on\n    String method = proceedingJoinPoint.getSignature().toShortString();\n    //System.out.println(\"\\n =======>>> @Around \" + method);\n\n    logger.info(\"\\n =======>>> @Around \" + method);\n\n    // get begin timestamp\n    long begin = System.currentTimeMillis();\n\n    // now, let's execute the method\n    Object result = null;\n\n    try {\n        result = proceedingJoinPoint.proceed();\n    }\n    catch (Exception e) {\n        // log the exception\n        logger.warning(e.getMessage());\n        // give user a message\n        result = \"It is an exception, but do not worry, we knew it\";\n    }\n```\n\n",
  "5dd9f67a4e96a55e951b463e": "# Interceptor \n\nWe need to compare the token in the cookie with the token in the current user. If we don't use Interceptor, we need to compare the logic on each page, so we use Interceptor to solve this problem.\n\n1. We need to define a Service to implement the HandlerInterceptor interface, then write the logic code in preHandle\n\n```java\n@Service\npublic class SessionInterceptor implements HandlerInterceptor {\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Override\n    public boolean preHandle(HttpServletRequest req, HttpServletResponse response, Object handler) throws Exception {\n        Cookie[] cookies = req.getCookies();\n        if (cookies!= null && cookies.length != 0) {\n            for (Cookie cookie : cookies ) {\n                if (cookie.getName().equals(\"token\")) {\n                    String token = cookie.getValue();\n                    QueryWrapper<User> wrapper = new QueryWrapper<>();\n                    wrapper.eq(\"token\", token);\n                    User user = userMapper.selectOne(wrapper);\n                    if (user != null) {\n                        req.getSession().setAttribute(\"user\", user);\n                    }\n                    break;\n                }\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {  }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {   }\n}\n```\n\n2. We also need to define a Webconfig to configure the Interceptor. Below we define a WebConfig to implement WebMvcConfigurer\n\n```java\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n\t// Dependency injection SessionInterceptor\n    @Autowired\n    private SessionInterceptor sessionInterceptor;\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        // All interceptors execute this interceptor\n        registry.addInterceptor(sessionInterceptor).addPathPatterns(\"/**\");\n    }\n}\n```\n\n# Error Handler\n\nWe expect that when the input url is wrong, it will jump to the corresponding error page. Here you need to use the Error Handler.\n\n## Basic usage\n\nSpring provides a way to capture 4xx and 5xx errors.\n\nFirst we define a Controller to implement ErrorController. Below we can capture is4xxClientError() and is5xxServerError() according to HttpStatus.\n\n```java\n@Controller\n@RequestMapping(\"${server.error.path:${error.path:/error}}\")\npublic class CustomizeErrorController implements ErrorController {\n    @Override\n    public String getErrorPath() {\n        return \"error\";\n    }\n\n    @RequestMapping(produces = MediaType.TEXT_HTML_VALUE)\n    ModelAndView errorHtml(HttpServletRequest request, Model model) {\n        HttpStatus status = getStatus(request);\n\n        if (status.is4xxClientError()) {\n            model.addAttribute(\"message\", \"Wrong request url, please check\");\n        }\n//        if (status.is5xxServerError()) {\n//            model.addAttribute(\"message\", \"unknown error, please contact laodu\");\n//        }\n        return new ModelAndView(\"error\");\n    }\n\n    private HttpStatus getStatus(HttpServletRequest request) {\n        Integer statusCode = (Integer) request.getAttribute(\"javax.servlet.error.status_code\");\n        if (statusCode == null) {\n            return HttpStatus.INTERNAL_SERVER_ERROR;\n        }\n        return HttpStatus.valueOf(statusCode);\n    }\n\n}\n\n```\n\n## Customize Error Handler\n\nIf the user is empty, or the problem is empty, we can only know that it is a 5xx problem, but we cannot return specific error information according to the specific problem. So we need costomize our own Error Handler\n\n1. First we have to define CustomizeErrorCode\n\n   Define the CustomizeErrorCode of the enum type, and set all the error prompts, and inherit the getMessage method of the interface\n\n   ```java\n   public interface ICustomizeErrorCode {\n       public String getMessage();\n   }\n   ```\n\n   ```java\n   public enum CustomizeErrorCode implements ICustomizeErrorCode{\n   \n       QUESTION_NOT_FOUND(\"The question you find is not exist\");\n   \n       private String message;\n   \n       @Override\n       public String getMessage() {\n           return message;\n       }\n   \n       CustomizeErrorCode(String message) {\n           this.message = message;\n       }\n   }\n   ```\n\n2. Then set the CustomizeException\n\n   CustomizeException to inherit RuntimeException, to monitor the exceptions that may occur while the program is running, and to construct a constructor that accepts the error in CustomizeErrorCode and assigns it to the message.\n\n   ```java\n   public class CustomizeException extends RuntimeException {\n   \n       private String message;\n   \n       public CustomizeException(ICustomizeErrorCode errorCode) {\n           this.message = errorCode.getMessage();\n       }\n   \n       public CustomizeException(String message) {\n           this.message = message;\n       }\n   \n       @Override\n       public String getMessage() {\n           return message;\n       }\n   }\n   ```\n\n3. Create a ControllerAdvice to handle the information that needs to be returned to the page when the exception occurs.\n\n   ```java\n   @ControllerAdvice(basePackageClasses = ExceptionHandlerAdvice.class)\n   public class ExceptionHandlerAdvice {\n   \n       @ExceptionHandler(Exception.class)\n       ModelAndView handle(HttpServletRequest request, Throwable e, Model model) {\n           //If the message above CustomizeException is different from the default message, return the custom message.\n           if (e instanceof CustomizeException){\n               model.addAttribute(\"message\", e.getMessage());\n   \n           }else{\n               model.addAttribute(\"message\", \"unknown error, please contact laodu\");\n           }\n   \t\t// Return to the error page\n           return new ModelAndView(\"error\");\n       }\n   }\n   ```\n\n   Add the following code wherever there is a problem with QUESTION_NOT_FOUND. That ‘s all\n\n   ```java\n   if (question == null) {\n       //Throws a custom exception, the enumeration code for the exception is QUESTION_NOT_FOUND\n               throw new CustomizeException(CustomizeErrorCode.QUESTION_NOT_FOUND);\n           }\n   ```\n\n   \n\n",
  "5ddd82a542e3142eb68f2666": "## How do the contents of html pass to ts?\n\nwe use [xx]=\"123\" => Input('xx') to pass the data\n\nhtml:\n\n```html\n<app-recipe-item\n      *ngFor=\"let recipe of recipes; let i = index\"\n      [recipe]=\"recipe\"\n      [index]=\"i\"\n    >\n    </app-recipe-item>\n```\n\nts:\n\n```typescript\n // tslint:disable-next-line:no-input-rename\n  @Input('recipe') recipe: Recipe;\n  // tslint:disable-next-line:no-input-rename\n  @Input('index') index: number;\n```\n\n\n\n## About[ ]\n\nThis is very confusing to me, sometimes it can be passed as ts as a value, and sometimes it can represent the attribute value in the html tag. such as:\n\n```html\n<img [src]=\"recipe.imagePath\"\n     class=\"img-responsive\"\n     style=\"max-height: 300px\"\n>\n```\n\n",
  "5ddd82f842e3142eb68f2667": "# Route\n\n\n\n## Architecture\n\n1. Create app-routing.module.ts in the same directory as app.module\n\n2. ```typescript\n   // import HttpClientModule in app module\n   import {HttpClientModule} from '@angular/common/http';\n   ```\n\n3. In app-routing.module.ts you want to define each custom module\n\n4. It's better to add lazy loading mechanism in app-routing.moudle.ts\n\n5. Each module must create its own module and xx-routing.module.ts, and don't forget to import in app.module\n\n\n\n## routerLink\n\n[routerLink] can find the router's root\n\n```html\n<a [routerLink]=\"[i]\">\n```\n\nFor example, under recipes, you will find this path under recipes-routing       recipes/:id\n\n[routerLinkActive]='active'\n\nWhen you click, you will make it active\n\n\n\n## ActivatedRoute\n\nHow to get the param in route in ts?\n\nFirst we need to introduce ActivatedRoute\n\nAnd then call its params\n\nts:\n\n```typescript\nid: number;\n\nconstructor( private route: ActivatedRoute,\n             ) { }\n\nngOnInit() {\n    this.route.params\n      .subscribe(\n        (params: Params) => {\n          this.id = +params.id;\n        }\n      );\n  }\n```\n\n\n\n## Router\n\nIf you want to jump to other pages, you need Router.\n\nts:\n\n```typescript\nconstructor( private route: ActivatedRoute,\n             private router: Router,\n              ) { }\n\nthis.router.navigate(['../', this.id, 'edit'], {relativeTo: this.route});\n```\n\nThe navigation is this path recipes /: id / edit\n\nrelativeTo is automatically transferred to the corresponding module's routing\n\n",
  "5ddd831f42e3142eb68f2668": "# Form\n\n\n\n## Reactive Form\n\nIf you want to use the Reactive Form function, you must define a FormGroup\n\nEach Group member must create its own FormControl,\n\nValidator can be added to validate form elements\n\nIf you have a group you need to add to the previous FormArray. You need to write a new FormArray, and then put the new as a Group member in the original FormGroup\n\n```typescript\nrecipeForm: FormGroup;\nconst recipeIngredients = new FormArray([]);\n\nfor (const ingredient of recipe.ingredients) {\n          recipeIngredients.push(\n            new FormGroup({\n              name: new FormControl(ingredient.name, Validators.required),\n              amount: new FormControl(ingredient.amount, [Validators.required, Validators.pattern('^[1-9]+[0-9]*$')])\n            })\n          );\n        }\n\n   this.recipeForm = new FormGroup({\n      name: new FormControl(recipeName, Validators.required),\n      imagePath: new FormControl(recipeImagePath, Validators.required),\n      description: new FormControl(recipeDescription, Validators.required),\n      ingredients: recipeIngredients\n    });\n```\n\nhtml display:\n\nFirst you need to add **[formGroup] = \"recipeForm\"** to the form tag\n\nAdd **formControlName = \"xxx\"** to each form element\n\nWe will use *** ngIf = \"! RecipeForm.get ('xxx'). Valid && recipeForm.get ('xxx'). Touched\"** to determine whether it has passed the verification\n\nInline formGroup we usually use *** ngIf = \"! RecipeForm.get (['ingredients', i, 'xxx']). Valid && recipeForm.get (['ingredients', i, 'xxx']). Touched\" >** To determine if it passed the verification\n\n```html\n<form [formGroup]=\"recipeForm\" (submit)=\"onSubmit()\">\n      <div class=\"row\">\n        <div class=\"col-xs-12\">\n          <div class=\"form-group\">\n            <label for=\"name\">Name</label>\n            <input\n              type=\"text\"\n              id=\"name\"\n              formControlName=\"name\"\n              class=\"form-control\">\n            <span\n              style=\"color: red\"\n              *ngIf=\"!recipeForm.get('name').valid && recipeForm.get('name').touched\">\n              Name is required\n            </span>\n          </div>\n        </div>\n      </div>\n      <div class=\"row\">\n        <div\n          class=\"col-xs-12\"\n          formArrayName=\"ingredients\">\n          <div\n            class=\"row\"\n            *ngFor=\"let ingredient of getControls(); let i = index\"\n            [formGroupName]=\"i\" style=\"margin-top: 10px\">\n            <div class=\"col-xs-8\">\n              <input\n                type=\"text\"\n                class=\"form-control\"\n                formControlName=\"name\">\n              <span\n                style=\"color: red\"\n                *ngIf=\"!recipeForm.get(['ingredients', i, 'name']).valid && recipeForm.get(['ingredients', i, 'name']).touched\">\n              Ingredient name is required\n              </span>\n            </div>\n            <div class=\"col-xs-2\">\n              <input\n                type=\"number\"\n                class=\"form-control\"\n                formControlName=\"amount\">\n              <span class=\"help-block\"\n                *ngIf=\"!recipeForm.get(['ingredients', i, 'amount']).valid && recipeForm.get(['ingredients', i, 'amount']).touched\">\n                <span style=\"color: red\" *ngIf=\"!recipeForm.get(['ingredients', i, 'amount']).errors['required']\">Amount cannot be negative number</span>\n                <span style=\"color: red\" *ngIf=\"!recipeForm.get(['ingredients', i, 'amount']).errors['pattern']\">Ingredient amount required</span>\n              </span>\n            </div>\n        </div>\n      </div>\n    </form>\n```\n\n",
  "5ddd837c42e3142eb68f2669": "# Observable\n\n\n\n## What is the publish-subscribe model?\n\nObservables, as observers, are a collection of streams of values or events; Observers, as observers, process according to Observables.\n\nThe subscription publishing relationship (observer mode) between Observables and Observer is as follows:\n\n- **Subscribe**：Observer subscribes to Observable through the subscribe () method provided by Observable.\n- **Publish**：Observable publishes events to Observer via callback next method.\n\n\n\n## How do the two Components interact with each other?\n\nWe need to use Subject, Observable, Subscription\n\n1. Generally we need to use services to interact\n\n\u200B\t①First define a Subject variable\n\n\u200B\t②Then you need to convert the Subject in the definition of an Observable variable\n\n\u200B\t③Define a method for changing data\n\n```typescript\nisAuthenticated = new Subject();\n\nauthObservable = this.isAuthenticated.asObservable();\n\nemitAuth(auth: boolean) {\n    this.isAuthenticated.next(auth);\n    this.isAuth = auth;\n  }\n```\n\n2. Then we publish the data in the passed component\n\n```typescript\nthis.authService.emitAuth(true);\n```\n\n3. Receive data on Compoent subscription data\n\n```typescript\nprivate authSub: Subscription;\nisAuthenticated = false;\n\n  // Use subscribe to subscribe. When the data is transmitted, the result will be received here.\n    this.authSub = this.authService.authObservable.subscribe(auth => {\n      this.isAuthenticated = auth;\n    });\n  }\n```\n\n\n\n",
  "5ddd915c15d8863d8ea8b994": "# Init react\n\ncreate-react-app can help us bulid the app qulicky\n\n```\nnpx create-react-app client\n```\n\n# Start C/S together\n\nIf we are developing together in the background, we need to start two servers. Very troublesome, so how to start the rescue and node services at the same time?\n\n1.\n\n```\nnpm install --save concurrently\n```\n\n2.\n\nin server side package.json add some code in scripts. Please notice that the client must under server.\n\n```javascript\n\"scripts\": {\n    \"start\": \"node index.js\",\n    \"server\": \"nodemon index.js\",\n    \"client\": \"npm run start --prefix client\",\n    \"dev\": \"concurrently \\\"npm run server\\\" \\\"npm run client\\\"\"\n  }\n```\n\n3. try to run\n\n```\nnpm run dev\n```\n\n# Proxy\n\n```html\n<a href=\"/auth/google\">\n```\n\nIf our react port is 3000, we click the link, it should be http://localhost:300/auth/google.\n\nBut we want to give the request to server. So in this case, we need to use proxy.\n\n1.\n\n```\nnpm install http-proxy-middleware --save\n```\n\n2. create a js file under client\n\n```javascript\nconst proxy = require('http-proxy-middleware');\n\nmodule.exports = function(app) {\n    app.use(proxy(['/api', '/auth/google'], { target: 'http://localhost:5000' }));\n};\n```\n\nIn fact, we give the url http://localhost:300/auth/google to server. in other word, the client give server proxy.",
  "5ddd91f1c592802802d6887f": "# Router\n\n## react-router-dom\n\nFragment is an outermost frame, which can be regarded as the outermost <div>\n\nBrowserRouter only uses this for internal routing\n\nSwitch is literally\n\nRoute according to different paths and components\n\n```javascript\nimport React, {Fragment} from 'react';\nimport {BrowserRouter, Route, Switch} from 'react-router-dom';\nimport './App.css';\n\nimport Navbar from \"./components/layout/Navbar\";\nimport Landing from \"./components/layout/Landing\";\nimport Register from \"./components/auth/Register\";\nimport Login from \"./components/auth/Login\";\n\nconst App = () =>\n    <BrowserRouter>\n        <Fragment>\n            <Navbar/>\n            <Route exact path='/' component={Landing}/>\n            <section className=\"container\">\n                <Switch>\n                    <Route exact path='/register' component={Register}/>\n                    <Route exact path='/login' component={Login}/>\n                </Switch>\n            </section>\n        </Fragment>;\n    </BrowserRouter>\nexport default App;\n\n```\n\n## PrivateRoute\n\nIt is same like a interceptor, take any unauthentcated request to login route.\n\n```javascript\n/**\n * Created by Kaizhi Du on 2019/11/7.\n */\nimport React from 'react';\nimport {Route, Redirect} from 'react-router-dom';\nimport {connect} from \"react-redux\";\n\nconst PrivateRoute = ({component: Component, auth, ...rest}) => (\n    <Route\n        {...rest}\n        render={props =>\n                // if is not authenticated, we redicect to login route\n            !auth.isAuthenticated ? (\n                <Redirect to='/login'/>\n            ) : (\n                <Component {...props}/>\n                )\n        }\n    />\n);\n\nconst mapStateToProps = state => ({\n    auth: state.auth\n});\n\nexport default connect(mapStateToProps)(PrivateRoute);\n```\n\n# ",
  "5ddd92c10965800a5e70f107": "# Component State\n\nComponent state is a local parameter.\n\nWhen a component mount, the component state is init, we this component unmount, destroy it.\n\n```javascript\nclass SurveyNew extends Component {\n\n    // init the state\n    state = {showFormReview: false};\n\n    renderContent() {\n        // judge this. if true, send a prop to SurveyFormReview; else send a prop to SurveyForm\n        if (this.state.showFormReview) {\n            return <SurveyFormReview\n                onCancelClick={() => this.setState({showFormReview: false})}\n            />\n        }\n        return <SurveyForm\n            onFormSubmit={() => this.setState({showFormReview: true})}\n        />\n    }\n\n    render() {\n        return (\n            <div>\n                {this.renderContent()}\n            </div>\n        )\n    }\n}\n\nexport default reduxForm({\n    form: 'surveyForm'\n})(SurveyNew);\n```\n\n# Hooks\n\nwe use arrow function instead of class component\n\n```javascript\n/**\n * Created by mqd on 2019/11/5.\n */\nimport React, {Fragment, useState} from 'react';\nimport {Link} from \"react-router-dom\";\n\n// we use arrow function instead of class component\nconst Login = () => {\n    // it is component state\n    const [formData, setFormData] = useState({\n        email: '',\n        password: ''\n    });\n    // the email and password must match the value of form\n    const {email, password} = formData;\n\t// when email/password change, the formData will change\n    const onChange = e => setFormData({\n        ...formData, [e.target.name]: e.target.value\n    });\n\t// when user sumbit, we can see all the value of form\n    const onSubmit = e => {\n        e.preventDefault();\n        console.log(formData);\n    };\n\n    return <Fragment>\n        <h1 className=\"large text-primary\">Sign In</h1>\n        <p className=\"lead\"><i className=\"fas fa-user\"></i> Create Your Account</p>\n        <form className=\"form\" action=\"create-profile.html\" onSubmit={e => onSubmit(e)}>\n            <div className=\"form-group\">\n                <input type=\"email\" placeholder=\"Email Address\" name=\"email\" value={email} onChange={e => onChange(e)}/>\n                <small className=\"form-text\"\n                >This site uses Gravatar so if you want a profile image, use a\n                    Gravatar email\n                </small>\n            </div>\n            <div className=\"form-group\">\n                <input\n                    type=\"password\"\n                    placeholder=\"Password\"\n                    name=\"password\"\n                    minLength=\"6\"\n                    value={password} onChange={e => onChange(e)}\n                />\n            </div>\n            <input type=\"submit\" className=\"btn btn-primary\" value=\"Login\"/>\n        </form>\n        <p className=\"my-1\">\n            Do not have an account? <Link to=\"/register\">Sign Up</Link>\n        </p>\n    </Fragment>;\n};\n\nexport default Login\n```\n\n",
  "5ddd960e62fdae442ed43a8c": "# Create project\n\ngit init\n\nnpm init\n\n## Req and Res\n\n**req.body**  we can get the body information from req.body\n\n**req.params** we can get route path  information from req.params\n\n**res.send()** we can send a message use res.send()\n\n**res.json({})** we can send a json use res.json({})\n\n# Server validation\n\n```javascript\nconst {check, validationResult} = require('express-validator');\nrouter.post('/', authMiddleware,\n            // we define the role of validation in there\n    [\n        check('status', 'Status is required').not().isEmpty(),\n        check('skills', 'Skills is required').not().isEmpty()\n    ],\n    async (req, res) => {\n    // we can parse the req to validationResult, to check status and skills\n        const errors = validationResult(req);\n    // if there have error, the errors should not be expty\n        if (!errors.isEmpty()) {\n            return res.status(400).json({errors: errors.array()});\n        }\n```\n\n",
  "5ddd97650a5b5a467251c73a": "# mangoDB\n\n## 1. create the Atlas\n\nSign up a account, after sign up, we can create a cluster.\n\nwe need to create a user \n\nthen, choose connect your application and copy this code\n\nfinal add this code to key.js\n\n## 2. Schema\n\nUnder model, create new survey.js\n\nIf a survey corresponds to multiple Recipients, we can use an array to represent\n\nIf survey and user are one-to-one, we can use {type: Schema.Types.ObjectId, ref: 'User'} to represent\n\n```javascript\n//survey.js\nconst surveySchema = new Schema({\n    title: String,\n    body: String,\n    subject: String,\n    recipients: [RecipientSchema],\n    yes: {type: Number, default: 0},\n    no: {type: Number, default: 0},\n    dataSent: Date,\n    lastResponded: Date,\n    _user: {type: Schema.Types.ObjectId, ref: 'User'}\n});\n```\n\n```javascript\n//recipient.js\nconst recipientSchema = new Schema({\n    email: String,\n    responded: {type: Boolean, default: false}\n});\n```\n\n### Important Point\n\nIf we want to reference the ID of another schema in a schema:\n\n```javascript\n user: {\n        type: mongoose.Schema.Types.ObjectId,\n        ref: 'user'\n    },\n```\n\nIf we want to add another object to one object:\n\n```javascript\nuser: {\n    experience: [\n        {\n            title: {type: String, required: true},\n            company: {type: String, required: true},\n            location: {type: String},\n            from: {type: Date, required: true},\n            to: {type: Date},\n            current: {type: Boolean, default: false},\n            description: {type: String}\n        }\n    ]\n}\n```\n\n## 3. Mongoose\n\nCreate a new Schema\n\n```javascript\nconst Profile = require('../../models/Profile');\n\nprofile = new Profile({\n    xx: xx\n});\nprofile.save();\n```\n\nHow to change child objects in an object\n\n```javascript\nprofile.education.unshift(newEdu);\n```\n\nHow to delete an element of a child object in an object\n\n```javascript\nconst removeIndex = profile.education.map(item => item._id).indexOf(req.params.edu_id);\nprofile.education.splice(removeIndex, 1);\n```\n\nCheck if there is required data\n\n```javascript\n// check if the post has already been liked\n        if (post.likes.filter(like => like.user.toString() === req.user.id).length > 0) {\n            return res.status(400).json({msg: \"Post already liked\"});\n        }\n```\n\n",
  "5ddd9a7b0235f1469e89813d": "# Basic setup\n\nwe need a js file to write our store\n\n```javascript\n// store.js under src folder\nimport {createStore, applyMiddleware} from 'redux';\nimport {composeWithDevTools} from 'redux-devtools-extension';\nimport thunk from 'redux-thunk';\nimport rootReducer from './reducers';\n\nconst initialState = {};\n\nconst middleware = [thunk];\n\nconst store = createStore(rootReducer, initialState, composeWithDevTools(applyMiddleware(...middleware)));\n\nexport default store;\n```\n\nin our app component, we need to import store, and use the Provider to wrap all the code\n\n```javascript\n// Redux\n// Redux and react is separate, we use react-redux combine together\nimport {Provider} from 'react-redux';\nimport store from './store';\n\n<Provider store={store}>\n    .....\n    </Provider>\n```\n\n",
  "5ddd9b16ffd6cd1cd6d247a7": "## 1. Define the backend router\n\nA set of surveys is retrieved from the database via the previously defined model and is ready to be returned to the frontend via res.send().\n\n```javascript\n app.get('/api/surveys', requireLogin, async (req, res) => {\n        const surveys = await Survey.find({_user: req.user.id});\n        res.send(surveys);\n    });\n```\n\n## 2. Define action\n\nDefine type, here is the call to facilitate the reducer.\n\n```javascript\nexport const FETCH_SURVEYS = 'fetch_surveys';\n```\n\nDefine action creator, \n\nWe fetch the data from the backend through axios.\n\nsent to the reducer through the dispatch, which includes type (distinguish different actions) and payload (specific data)\n\n```javascript\nexport const fetchSurveys = () => async dispatch => {\n    const res = await axios.get('/api/surveys');\n    dispatch({type: FETCH_SURVEYS, payload: res.data})\n};\n```\n\n## 3. Define reducer\n\nFirst, you need to reference the type inside the action to distinguish which action is\n\nThen use switch to judge, if type is FETCH_SURVEYS, use payload to update redux state\n\n```javascript\nimport {FETCH_SURVEYS} from '../actions/type';\n\nexport default function (state = [], action) {\n    switch (action.type) {\n        case FETCH_SURVEYS:\n            return action.payload || false;\n        default:\n            return state;\n    }\n}\n\n```\n\nFinally, don't forget to add the new reducer to the combineReducer.\n\n```javascript\nexport default combineReducers({\n    auth: authReducer,\n    surveys: surveysReducer,\n    form: reduxFormReducer\n});\n```\n\n## ",
  "5ddd9b9e9b909afffd418894": "## Create component\n\ncreate a class\n\n```javascript\nclass SurveysList extends Component {\n          render() {\n        return (\n            <div>\n              \tSurveys\n            </div>\n        )\n    }\n}\n```\n\nimport the actions\n\n```javascript\nimport * as actions from \"../../actions\";\nclass SurveysList extends Component {\n        render() {\n        return (\n            <div>\n               Surveys\n            </div>\n        )\n    }\n}\n```\n\ncreate connect,and create mapStateToProps function.\n\nIf we want to render data to the page, we must use props, the use of mapStateToProps is to convert the data in the redux state to props.\n\nconnect need to connect with mapStateToProps,action,and class.\n\n```javascript\nimport React, {Component} from \"react\";\nimport {connect} from \"react-redux\";\nimport * as actions from \"../../actions\";\n\nclass SurveysList extends Component {\n\n    render() {\n        return (\n            <div>\n                Surveys\n            </div>\n        )\n    }\n}\n\nfunction mapStateToProps(state) {\n    return {surveys: state.surveys}\n}\n\nexport default connect(mapStateToProps, actions)(SurveysList);\n```\n\nThen we need to add lifecycle. componentDidMount is when the class is mounted, trigger action - fetchSurveys\n\n```javascript\nimport React, {Component} from \"react\";\nimport {connect} from \"react-redux\";\nimport * as actions from \"../../actions\";\n\nclass SurveysList extends Component {\n\n    componentDidMount() {\n        this.props.fetchSurveys();\n    }\n    \n    render() {\n        return (\n            <div>\n                Surveys\n            </div>\n        )\n    }\n}\n\nfunction mapStateToProps(state) {\n    return {surveys: state.surveys}\n}\n\nexport default connect(mapStateToProps, actions)(SurveysList);\n```\n\nThen we can get the data through this.props.surveys, and then we can render to the page. Usage is {xx.xx}\n\n```javascript\nimport React, {Component} from \"react\";\nimport {connect} from \"react-redux\";\nimport * as actions from \"../../actions\";\n\nclass SurveysList extends Component {\n\n    componentDidMount() {\n        this.props.fetchSurveys();\n    }\n\n    renderSurveys() {\n        return this.props.surveys.map(survey => {\n            return (\n                <div className=\"card darken-1\" key={survey._id}>\n                    <div className=\"card-content\">\n                         <span className=\"card-title\">\n                             {survey.title}\n                         </span>\n                        <p>\n                            {survey.body}\n                        </p>\n                        <p className=\"right\">\n                            Send on: {survey.dateSent}\n                        </p>\n                    </div>\n                </div>\n            )\n        });\n    }\n\n    render() {\n        return (\n            <div>\n                {this.renderSurveys()}\n            </div>\n        )\n    }\n}\n\nfunction mapStateToProps(state) {\n    return {surveys: state.surveys}\n}\n\nexport default connect(mapStateToProps, actions)(SurveysList);\n```\n\n# ",
  "5ddd9f7e487b57423a94306a": "# Define redux-form reducer\n\nredux-form take the reducer by itself, so we only need to invoke it.\n\n```javascript\nimport {combineReducers} from \"redux\";\nimport {reducer as reduxFormReducer} from \"redux-form\";\nimport authReducer from \"./authReducer\";\n\nexport default combineReducers({\n    auth: authReducer,\n    form: reduxFormReducer\n});\n```\n\n# Define the template of Field\n\nFields that use SurveyField will follow the rules below.\n\n```javascript\nimport React from \"react\";\n// input is come form props.input\nexport default ({input, label}) => {\n    return (\n        <div>\n            <label>{label}</label>\n            <input {...input} />\n        </div>\n    )\n}\n```\n\n# ",
  "5ddd9fbfb2760ed5cd2fd292": "# Redux-form\n\n```javascript\nimport _ from 'lodash';\nimport React, {Component} from \"react\";\nimport {reduxForm, Field} from \"redux-form\";\nimport SurveyField from \"./SurveyField\";\nimport {Link} from \"react-router-dom\";\n\n// when we change the input, the redux-form will auto save the data to redux store\n// this.props.handleSubmit is provide by reduxForm\n// SurveyField is a template of Field\n\nconst FIELDS = [\n    {label: 'Survey Title', name: 'surveyTitle'},\n    {label: 'Survey Line', name: 'surveyLine'},\n    {label: 'Email Body', name: 'emailBody'},\n    {label: 'Recipient List', name: 'recipientList'}\n];\n\nclass SurveyForm extends Component {\n\n    // We loop the FIELDS to call the Field template SurveyField.\n    renderFields() {\n        return _.map(FIELDS, ({label, name}) => {\n            return <Field type=\"text\" label={label} name={name} component={SurveyField}/>\n        });\n    }\n\n    render() {\n        return (\n            <div>\n                <form onSubmit={this.props.handleSubmit(values => console.log(values))}>\n                    {this.renderFields()}\n                    <Link to='/surveys' className='red btn-flat white-text'>\n                        Cancel\n                    </Link>\n                    <button className='btn btn-info right' type='submit'>\n                        Next\n                        <i className='material-icons right'>done</i>\n                    </button>\n                </form>\n            </div>\n        );\n    }\n}\n\n// It's very similar to redux, we need to set the name to surveyForm to be redux-form\nexport default reduxForm({\n    form: 'surveyForm'\n})(SurveyForm);\n```\n\n",
  "5ddd9ff92b76df2496730941": "# Validation\n\nFirst of all, we need to add validate to reduxForm\n\n```javascript\nexport default reduxForm({\n    validate,\n    form: 'surveyForm'\n})(SurveyForm);\n```\n\nThen, we need to create a function named vaildate\n\n```javascript\n// the values is the object coming from our form\n// error is metaData from our form\nfunction validate(values) {\n    const errors = {};\n\n    errors.recipientList = validateEmails(values.recipientList || '');\n\n    if (!values.surveyTitle) {\n        errors.surveyTitle = \"You must provide a title\";\n    }\n    if (!values.surveyLine) {\n        errors.surveyLine = \"You must provide a survey line\";\n    }\n    if (!values.emailBody) {\n        errors.emailBody = \"You must provide a email body\";\n    }\n    if (!values.recipientList) {\n        errors.recipientList = \"You must provide at least one recipient\";\n    }\n\n    return errors;\n}\n```\n\nin our Field template,we need to let our form show the error.\n\n```javascript\nimport React from \"react\";\n// input is come form props.input\n// meta is html metadata\n// {touched && error} mean if you have error or touch , this message will show.\nexport default ({input, label, meta: {error, touched}}) => {\n    return (\n        <div>\n            <label>{label}</label>\n            <input style={{marginBottom: '5px'}} {...input} />\n            <div className=\"red-text\">\n                {touched && error}\n            </div>\n        </div>\n    )\n}\n```\n\n"
}