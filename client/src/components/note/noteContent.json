{
  "5dd9cdb581ca03e15c7df20c": "# Spring Container\n\n## Inversion of Control\n\nIOC means giving your designed objects to the spring container control instead of the traditional direct control inside your object.\n\n## Dependency Injection\n\nDependency : dependent spring container.\n\nInjection: The spring container injects the required object\n\n# Basic useful annotation\n\n## @Qualifier\n\n@Qualifier: If tow class implements one interface, we need to use qualifier to distinguish them.\n\n```java\n\t@Autowired\n    @Qualifier(\"happyFortune\")\n    private HappyFortune happyFortune;\n\n    @Autowired\n    @Qualifier(\"randomFortune\")\n    private RandomFortune randomFortune;\n```\n\n## @PostConstruct\n\n@PostConstruct: define initial method, only execute once.\n\n```java\n@PostConstruct\n    public void doMyStartupStuff() {\n        System.out.println(\"we call the init method\");\n    }\n```\n\n## @InitBinder\n\n@InitBinder: pre-process all web requests coming into this Controller\n\n```java\n@InitBinder\n    // add an initbinder to convert trim input string\n    public void initBinder(WebDataBinder dataBinder) {\n        StringTrimmerEditor stringTrimmerEditor = new StringTrimmerEditor(true);\n        dataBinder.registerCustomEditor(String.class, stringTrimmerEditor);\n    }\n```\n\n# Validation\n\n## Annotation from spring\n\n```java\n@NotNull(message = \"firstName is required\")\n    @Size(min = 1, message = \"size must >1\")\n    private String firstName;\n```\n\n## Customize annotation\n\n```java\n@CourseCode\n    private String courseCode;\n```\n\n```java\n@Constraint(validatedBy =  CourseCodeConstrainValidator.class)\n//where are we use this annotation\n@Target( { ElementType.METHOD, ElementType.FIELD})\n//Retain this annotation in the java class file\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface CourseCode {\n    // define default course code\n    public String value() default \"LUV\";\n    // define default error message\n    public String message() default \"must start with LUV\";\n    // define default groups\n    public Class<?>[] groups() default {};\n    // define default payload\n    public Class<? extends Payload>[] payload() default {};\n\n}\n```\n\n```java\npublic class CourseCodeConstrainValidator implements ConstraintValidator<CourseCode, String>{\n    private String coursePrefix;\n    @Override\n    public void initialize(CourseCode theCourseCode) {\n        coursePrefix = theCourseCode.value();\n    }\n    @Override\n    //SpringMVC will call is Valid\n    public boolean isValid(String theCode, ConstraintValidatorContext constraintValidatorContext) {\n        boolean result;\n        if (theCode != null) result = theCode.startsWith(coursePrefix);\n        else result = true;\n        return result;\n    }\n}\n```\n\n",
  "5dd9cf56c3cf5851159c5a50": "# Hibernate\n\n## Basic method\n\n***fetch = FetchType.LAZY***   lazy loading, when loading an entity, properties that define lazy loading will not load from the database right away.\n\n***fetch = FetchType.EAGER*** eager loading, when an entity is loaded, the property that defines the rush loading will be loaded immediately from the database.\n\n***cascade = CascadeType.ALL*** refers to a cascading relationship, any operation will affect the corresponding cascading.\n\n## OneToOne\n\n\u200B\tStudent and Course's relationship is OneToOne\n\n```java\n//Student\n@OneToOne(cascade = CascadeType.ALL)\n    //Foreign key name in database\n    @JoinColumn(name = \"course_id\")\n    private Course course;\n```\n\n```java\n//Course\n//mappedBy refers to property course in Student class\n    @OneToOne(mappedBy = \"course\", cascade = CascadeType.ALL)\n    private Student student;\n```\n\n## OneToMany\n\n\u200B\tStudent and hobby's relationship is OneToMany\n\n```java\n//Student\n//we do not want to add the delete rule in the cascade\n    @OneToMany(fetch = FetchType.LAZY, mappedBy = \"student\", cascade = {CascadeType.PERSIST, CascadeType.REFRESH, CascadeType.MERGE, CascadeType.DETACH})\n    private List<Hobby> hobbies;\n```\n\n```java\n//Hobby\n//we do not want to add the delete rule in the cascade\n    @ManyToOne(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST, CascadeType.REFRESH, CascadeType.MERGE, CascadeType.DETACH})\n    @JoinColumn(name = \"student_id\")\n    private Student student;\n```\n\n## ManyToMany\n\n\u200B\tTeacher and course's relationship is ManyToMany\n\n```java\n//Teacher\n@ManyToMany(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST, CascadeType.REFRESH, CascadeType.MERGE, CascadeType.DETACH})\n@JoinTable(\n        name = \"teacher_course\",\n        joinColumns = @JoinColumn(name = \"teacher_id\"),\n        inverseJoinColumns = @JoinColumn(name = \"course_id\")\n)\nprivate List<Course> courses;\n```\n\n```java\n//Course\n@ManyToMany(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST, CascadeType.REFRESH, CascadeType.MERGE, CascadeType.DETACH})\n@JoinTable(\n        name = \"teacher_course\",\n        joinColumns = @JoinColumn(name = \"course_id\"),\n        inverseJoinColumns = @JoinColumn(name = \"teacher_id\")\n)\nprivate List<Teacher> teachers;\n```\n\n",
  "5dd9f5be538cba7031094498": "# Hibernate\n\n## Basic method\n\n***fetch = FetchType.LAZY***   lazy loading, when loading an entity, properties that define lazy loading will not load from the database right away.\n\n***fetch = FetchType.EAGER*** eager loading, when an entity is loaded, the property that defines the rush loading will be loaded immediately from the database.\n\n***cascade = CascadeType.ALL*** refers to a cascading relationship, any operation will affect the corresponding cascading.\n\n## OneToOne\n\n\u200B\tStudent and Course's relationship is OneToOne\n\n```java\n//Student\n@OneToOne(cascade = CascadeType.ALL)\n    //Foreign key name in database\n    @JoinColumn(name = \"course_id\")\n    private Course course;\n```\n\n```java\n//Course\n//mappedBy refers to property course in Student class\n    @OneToOne(mappedBy = \"course\", cascade = CascadeType.ALL)\n    private Student student;\n```\n\n## OneToMany\n\n\u200B\tStudent and hobby's relationship is OneToMany\n\n```java\n//Student\n//we do not want to add the delete rule in the cascade\n    @OneToMany(fetch = FetchType.LAZY, mappedBy = \"student\", cascade = {CascadeType.PERSIST, CascadeType.REFRESH, CascadeType.MERGE, CascadeType.DETACH})\n    private List<Hobby> hobbies;\n```\n\n```java\n//Hobby\n//we do not want to add the delete rule in the cascade\n    @ManyToOne(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST, CascadeType.REFRESH, CascadeType.MERGE, CascadeType.DETACH})\n    @JoinColumn(name = \"student_id\")\n    private Student student;\n```\n\n## ManyToMany\n\n\u200B\tTeacher and course's relationship is ManyToMany\n\n```java\n//Teacher\n@ManyToMany(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST, CascadeType.REFRESH, CascadeType.MERGE, CascadeType.DETACH})\n@JoinTable(\n        name = \"teacher_course\",\n        joinColumns = @JoinColumn(name = \"teacher_id\"),\n        inverseJoinColumns = @JoinColumn(name = \"course_id\")\n)\nprivate List<Course> courses;\n```\n\n```java\n//Course\n@ManyToMany(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST, CascadeType.REFRESH, CascadeType.MERGE, CascadeType.DETACH})\n@JoinTable(\n        name = \"teacher_course\",\n        joinColumns = @JoinColumn(name = \"course_id\"),\n        inverseJoinColumns = @JoinColumn(name = \"teacher_id\")\n)\nprivate List<Teacher> teachers;\n```\n\n\n\n# AOP\n\n## @Pointcut\n\n\u200B\t@PointCut is a set of one or more JoinPoint where an advice should be executed. \n\n```java\n@Pointcut(\"execution(* com.kevin.dao.*.*(..))\")\npublic void daoPackage() {}\n\n@Pointcut(\"execution(* com.kevin.dao.*.get*(..))\")\npublic void getter() {}\n\n@Pointcut(\"execution(* com.kevin.dao.*.set*(..))\")\npublic void setter() {}\n\n@Pointcut(\"daoPackage() && !(getter() || setter())\")\npublic void forDaoPackageNoGetterSetter() {}\n```\n\n## @Before @After  \n\n```java\n@Before(\"com.kevin.aspect.AopExpression.forDaoPackageNoGetterSetter()\")\npublic void beforeDAO(JoinPoint joinPoint) {\n    System.out.println(\"\\n=========>>>>>  Now we run the before\");\n\n    // display the method signature\n    MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();\n\n    System.out.println(\"Method: \" +methodSignature);\n\n    // display method arguments\n    Object[] args = joinPoint.getArgs();\n    for (Object tempArg : args) {\n        if (tempArg instanceof Account) {\n            // downcast and print Account specific stuff\n            Account account = (Account) tempArg;\n            System.out.println(\"account name: \"+account.getName());\n            System.out.println(\"account level: \"+account.getLevel());\n\n        }\n    }\n}\n```\n\n## @AfterReturning\n\n```java\n@AfterReturning(\n        pointcut = \"execution(* com.kevin.dao.AccountDAO.findAccounts(..))\",\n        returning = \"result\")\npublic void afterReturningFindAccountsAdvice(JoinPoint joinPoint, List<Account> result){\n    // print out which method we are advising on\n    String method = joinPoint.getSignature().toShortString();\n    System.out.println(\"\\n =======>>> @AfterReturning \" + method);\n    // print out the result of the method call\n    System.out.println(\"result is: \" + result);\n\n    // let's post-process the data ...Let's modify it\n\n    // convert the account names to uppercase\n\n    convertAccountNamesToUppercase(result);\n\n    System.out.println(\"result(Uppercase) is: \" + result);\n\n}\n\nprivate void convertAccountNamesToUppercase(List<Account> result) {\n        // loop through accounts\n        for (Account account : result ) {\n        // get uppercase version of name\n        String upperName = account.getName().toUpperCase();\n        // update the name on the account\n            account.setName(upperName);\n        }\n    }\n```\n\n## @AfterThrowing\n\n```java\n@AfterThrowing(\n            pointcut = \"execution(* com.kevin.dao.AccountDAO.findAccounts(..))\",\n            throwing = \"e\")\n    public void afterThrowingFindAccountsAdvice(JoinPoint joinPoint, Throwable e) {\n        // print out which method we are advising on\n        String method = joinPoint.getSignature().toShortString();\n        System.out.println(\"\\n =======>>> @AfterThrowing \" + method);\n\n        // log the exception\n        System.out.println(\"\\n Exception is \" + e);\n    }\n```\n\n## @ExceptionHandler\n\nSometime we need to return a JSON data instead of error page, when the error happen. So we need to use the ExceptionHandler.\n\n```JAVA\n// If we want to use the ExceptionHandler, we need to use @ControllerAdvice\n@ControllerAdvice\npublic class StudentRestExceptionHandler {\n\n    // Add an exception handler using @ExceptionHandler\n    @ExceptionHandler\n    public ResponseEntity<StudentErrorResponse> handleException(StudentNotFoundException e) {\n        // create a StudentErrorResponse\n        StudentErrorResponse error = new StudentErrorResponse();\n        error.setStatus(HttpStatus.NOT_FOUND.value());\n        error.setMessage(e.getMessage());\n        error.setTimeStamp(System.currentTimeMillis());\n\n        // return ResponseEntity\n        return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);\n    }\n\n    // add another exception handler\n    @ExceptionHandler\n    public ResponseEntity<StudentErrorResponse> handleException2(Exception e) {\n\n        // create a StudentErrorResponse\n        StudentErrorResponse error = new StudentErrorResponse();\n        error.setStatus(HttpStatus.BAD_REQUEST.value());\n        error.setMessage(e.getMessage());\n        error.setTimeStamp(System.currentTimeMillis());\n\n        // return ResponseEntity\n        return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST);\n    }\n}\n```\n\n```java\n// 404 \npublic class StudentNotFoundException extends RuntimeException{\n\n    public StudentNotFoundException(String message) {\n        super(message);\n    }\n\n    public StudentNotFoundException(String message, Throwable cause) {\n        super(message, cause);\n    }\n\n    public StudentNotFoundException(Throwable cause) {\n        super(cause);\n    }\n}\n```\n\n```java\n// status javaBean\npublic class StudentErrorResponse {\n    private int status;\n    private long timeStamp;\n    private String message;\n}\n```\n\n```java\n@GetMapping(\"/student/{studentId}\")\npublic Student getStudent(@PathVariable int studentId) {\n\n    // check the studentId against list size\n    if ((studentId >= students.size()) || (studentId < 0) ){\n        throw new StudentNotFoundException(\"StudentId is not found \"+studentId);\n    }\n\n    return students.get(studentId);\n}\n```\n\n## @Around\n\n```java\n@Around(\"execution(* com.kevin.service.TrafficFortuneService.getFurtune(..))\")\npublic Object aroundGetFortune(ProceedingJoinPoint proceedingJoinPoint) throws Throwable{\n\n    // print out method we are advising on\n    String method = proceedingJoinPoint.getSignature().toShortString();\n    //System.out.println(\"\\n =======>>> @Around \" + method);\n\n    logger.info(\"\\n =======>>> @Around \" + method);\n\n    // get begin timestamp\n    long begin = System.currentTimeMillis();\n\n    // now, let's execute the method\n    Object result = null;\n\n    try {\n        result = proceedingJoinPoint.proceed();\n    }\n    catch (Exception e) {\n        // log the exception\n        logger.warning(e.getMessage());\n        // give user a message\n        result = \"It is an exception, but do not worry, we knew it\";\n    }\n```\n\n",
  "5dd9f67a4e96a55e951b463e": "# Interceptor \n\nWe need to compare the token in the cookie with the token in the current user. If we don't use Interceptor, we need to compare the logic on each page, so we use Interceptor to solve this problem.\n\n1. We need to define a Service to implement the HandlerInterceptor interface, then write the logic code in preHandle\n\n```java\n@Service\npublic class SessionInterceptor implements HandlerInterceptor {\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Override\n    public boolean preHandle(HttpServletRequest req, HttpServletResponse response, Object handler) throws Exception {\n        Cookie[] cookies = req.getCookies();\n        if (cookies!= null && cookies.length != 0) {\n            for (Cookie cookie : cookies ) {\n                if (cookie.getName().equals(\"token\")) {\n                    String token = cookie.getValue();\n                    QueryWrapper<User> wrapper = new QueryWrapper<>();\n                    wrapper.eq(\"token\", token);\n                    User user = userMapper.selectOne(wrapper);\n                    if (user != null) {\n                        req.getSession().setAttribute(\"user\", user);\n                    }\n                    break;\n                }\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {  }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {   }\n}\n```\n\n2. We also need to define a Webconfig to configure the Interceptor. Below we define a WebConfig to implement WebMvcConfigurer\n\n```java\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n\t// Dependency injection SessionInterceptor\n    @Autowired\n    private SessionInterceptor sessionInterceptor;\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        // All interceptors execute this interceptor\n        registry.addInterceptor(sessionInterceptor).addPathPatterns(\"/**\");\n    }\n}\n```\n\n# Error Handler\n\nWe expect that when the input url is wrong, it will jump to the corresponding error page. Here you need to use the Error Handler.\n\n## Basic usage\n\nSpring provides a way to capture 4xx and 5xx errors.\n\nFirst we define a Controller to implement ErrorController. Below we can capture is4xxClientError() and is5xxServerError() according to HttpStatus.\n\n```java\n@Controller\n@RequestMapping(\"${server.error.path:${error.path:/error}}\")\npublic class CustomizeErrorController implements ErrorController {\n    @Override\n    public String getErrorPath() {\n        return \"error\";\n    }\n\n    @RequestMapping(produces = MediaType.TEXT_HTML_VALUE)\n    ModelAndView errorHtml(HttpServletRequest request, Model model) {\n        HttpStatus status = getStatus(request);\n\n        if (status.is4xxClientError()) {\n            model.addAttribute(\"message\", \"Wrong request url, please check\");\n        }\n//        if (status.is5xxServerError()) {\n//            model.addAttribute(\"message\", \"unknown error, please contact laodu\");\n//        }\n        return new ModelAndView(\"error\");\n    }\n\n    private HttpStatus getStatus(HttpServletRequest request) {\n        Integer statusCode = (Integer) request.getAttribute(\"javax.servlet.error.status_code\");\n        if (statusCode == null) {\n            return HttpStatus.INTERNAL_SERVER_ERROR;\n        }\n        return HttpStatus.valueOf(statusCode);\n    }\n\n}\n\n```\n\n## Customize Error Handler\n\nIf the user is empty, or the problem is empty, we can only know that it is a 5xx problem, but we cannot return specific error information according to the specific problem. So we need costomize our own Error Handler\n\n1. First we have to define CustomizeErrorCode\n\n   Define the CustomizeErrorCode of the enum type, and set all the error prompts, and inherit the getMessage method of the interface\n\n   ```java\n   public interface ICustomizeErrorCode {\n       public String getMessage();\n   }\n   ```\n\n   ```java\n   public enum CustomizeErrorCode implements ICustomizeErrorCode{\n   \n       QUESTION_NOT_FOUND(\"The question you find is not exist\");\n   \n       private String message;\n   \n       @Override\n       public String getMessage() {\n           return message;\n       }\n   \n       CustomizeErrorCode(String message) {\n           this.message = message;\n       }\n   }\n   ```\n\n2. Then set the CustomizeException\n\n   CustomizeException to inherit RuntimeException, to monitor the exceptions that may occur while the program is running, and to construct a constructor that accepts the error in CustomizeErrorCode and assigns it to the message.\n\n   ```java\n   public class CustomizeException extends RuntimeException {\n   \n       private String message;\n   \n       public CustomizeException(ICustomizeErrorCode errorCode) {\n           this.message = errorCode.getMessage();\n       }\n   \n       public CustomizeException(String message) {\n           this.message = message;\n       }\n   \n       @Override\n       public String getMessage() {\n           return message;\n       }\n   }\n   ```\n\n3. Create a ControllerAdvice to handle the information that needs to be returned to the page when the exception occurs.\n\n   ```java\n   @ControllerAdvice(basePackageClasses = ExceptionHandlerAdvice.class)\n   public class ExceptionHandlerAdvice {\n   \n       @ExceptionHandler(Exception.class)\n       ModelAndView handle(HttpServletRequest request, Throwable e, Model model) {\n           //If the message above CustomizeException is different from the default message, return the custom message.\n           if (e instanceof CustomizeException){\n               model.addAttribute(\"message\", e.getMessage());\n   \n           }else{\n               model.addAttribute(\"message\", \"unknown error, please contact laodu\");\n           }\n   \t\t// Return to the error page\n           return new ModelAndView(\"error\");\n       }\n   }\n   ```\n\n   Add the following code wherever there is a problem with QUESTION_NOT_FOUND. That ‘s all\n\n   ```java\n   if (question == null) {\n       //Throws a custom exception, the enumeration code for the exception is QUESTION_NOT_FOUND\n               throw new CustomizeException(CustomizeErrorCode.QUESTION_NOT_FOUND);\n           }\n   ```\n\n   \n\n",
  "5ddd82a542e3142eb68f2666": "## How do the contents of html pass to ts?\n\nwe use [xx]=\"123\" => Input('xx') to pass the data\n\nhtml:\n\n```html\n<app-recipe-item\n      *ngFor=\"let recipe of recipes; let i = index\"\n      [recipe]=\"recipe\"\n      [index]=\"i\"\n    >\n    </app-recipe-item>\n```\n\nts:\n\n```typescript\n // tslint:disable-next-line:no-input-rename\n  @Input('recipe') recipe: Recipe;\n  // tslint:disable-next-line:no-input-rename\n  @Input('index') index: number;\n```\n\n\n\n## About[ ]\n\nThis is very confusing to me, sometimes it can be passed as ts as a value, and sometimes it can represent the attribute value in the html tag. such as:\n\n```html\n<img [src]=\"recipe.imagePath\"\n     class=\"img-responsive\"\n     style=\"max-height: 300px\"\n>\n```\n\n",
  "5ddd82f842e3142eb68f2667": "# Route\n\n\n\n## Architecture\n\n1. Create app-routing.module.ts in the same directory as app.module\n\n2. ```typescript\n   // import HttpClientModule in app module\n   import {HttpClientModule} from '@angular/common/http';\n   ```\n\n3. In app-routing.module.ts you want to define each custom module\n\n4. It's better to add lazy loading mechanism in app-routing.moudle.ts\n\n5. Each module must create its own module and xx-routing.module.ts, and don't forget to import in app.module\n\n\n\n## routerLink\n\n[routerLink] can find the router's root\n\n```html\n<a [routerLink]=\"[i]\">\n```\n\nFor example, under recipes, you will find this path under recipes-routing       recipes/:id\n\n[routerLinkActive]='active'\n\nWhen you click, you will make it active\n\n\n\n## ActivatedRoute\n\nHow to get the param in route in ts?\n\nFirst we need to introduce ActivatedRoute\n\nAnd then call its params\n\nts:\n\n```typescript\nid: number;\n\nconstructor( private route: ActivatedRoute,\n             ) { }\n\nngOnInit() {\n    this.route.params\n      .subscribe(\n        (params: Params) => {\n          this.id = +params.id;\n        }\n      );\n  }\n```\n\n\n\n## Router\n\nIf you want to jump to other pages, you need Router.\n\nts:\n\n```typescript\nconstructor( private route: ActivatedRoute,\n             private router: Router,\n              ) { }\n\nthis.router.navigate(['../', this.id, 'edit'], {relativeTo: this.route});\n```\n\nThe navigation is this path recipes /: id / edit\n\nrelativeTo is automatically transferred to the corresponding module's routing\n\n",
  "5ddd831f42e3142eb68f2668": "# Form\n\n\n\n## Reactive Form\n\nIf you want to use the Reactive Form function, you must define a FormGroup\n\nEach Group member must create its own FormControl,\n\nValidator can be added to validate form elements\n\nIf you have a group you need to add to the previous FormArray. You need to write a new FormArray, and then put the new as a Group member in the original FormGroup\n\n```typescript\nrecipeForm: FormGroup;\nconst recipeIngredients = new FormArray([]);\n\nfor (const ingredient of recipe.ingredients) {\n          recipeIngredients.push(\n            new FormGroup({\n              name: new FormControl(ingredient.name, Validators.required),\n              amount: new FormControl(ingredient.amount, [Validators.required, Validators.pattern('^[1-9]+[0-9]*$')])\n            })\n          );\n        }\n\n   this.recipeForm = new FormGroup({\n      name: new FormControl(recipeName, Validators.required),\n      imagePath: new FormControl(recipeImagePath, Validators.required),\n      description: new FormControl(recipeDescription, Validators.required),\n      ingredients: recipeIngredients\n    });\n```\n\nhtml display:\n\nFirst you need to add **[formGroup] = \"recipeForm\"** to the form tag\n\nAdd **formControlName = \"xxx\"** to each form element\n\nWe will use *** ngIf = \"! RecipeForm.get ('xxx'). Valid && recipeForm.get ('xxx'). Touched\"** to determine whether it has passed the verification\n\nInline formGroup we usually use *** ngIf = \"! RecipeForm.get (['ingredients', i, 'xxx']). Valid && recipeForm.get (['ingredients', i, 'xxx']). Touched\" >** To determine if it passed the verification\n\n```html\n<form [formGroup]=\"recipeForm\" (submit)=\"onSubmit()\">\n      <div class=\"row\">\n        <div class=\"col-xs-12\">\n          <div class=\"form-group\">\n            <label for=\"name\">Name</label>\n            <input\n              type=\"text\"\n              id=\"name\"\n              formControlName=\"name\"\n              class=\"form-control\">\n            <span\n              style=\"color: red\"\n              *ngIf=\"!recipeForm.get('name').valid && recipeForm.get('name').touched\">\n              Name is required\n            </span>\n          </div>\n        </div>\n      </div>\n      <div class=\"row\">\n        <div\n          class=\"col-xs-12\"\n          formArrayName=\"ingredients\">\n          <div\n            class=\"row\"\n            *ngFor=\"let ingredient of getControls(); let i = index\"\n            [formGroupName]=\"i\" style=\"margin-top: 10px\">\n            <div class=\"col-xs-8\">\n              <input\n                type=\"text\"\n                class=\"form-control\"\n                formControlName=\"name\">\n              <span\n                style=\"color: red\"\n                *ngIf=\"!recipeForm.get(['ingredients', i, 'name']).valid && recipeForm.get(['ingredients', i, 'name']).touched\">\n              Ingredient name is required\n              </span>\n            </div>\n            <div class=\"col-xs-2\">\n              <input\n                type=\"number\"\n                class=\"form-control\"\n                formControlName=\"amount\">\n              <span class=\"help-block\"\n                *ngIf=\"!recipeForm.get(['ingredients', i, 'amount']).valid && recipeForm.get(['ingredients', i, 'amount']).touched\">\n                <span style=\"color: red\" *ngIf=\"!recipeForm.get(['ingredients', i, 'amount']).errors['required']\">Amount cannot be negative number</span>\n                <span style=\"color: red\" *ngIf=\"!recipeForm.get(['ingredients', i, 'amount']).errors['pattern']\">Ingredient amount required</span>\n              </span>\n            </div>\n        </div>\n      </div>\n    </form>\n```\n\n",
  "5ddd837c42e3142eb68f2669": "# Observable\n\n\n\n## What is the publish-subscribe model?\n\nObservables, as observers, are a collection of streams of values or events; Observers, as observers, process according to Observables.\n\nThe subscription publishing relationship (observer mode) between Observables and Observer is as follows:\n\n- **Subscribe**：Observer subscribes to Observable through the subscribe () method provided by Observable.\n- **Publish**：Observable publishes events to Observer via callback next method.\n\n\n\n## How do the two Components interact with each other?\n\nWe need to use Subject, Observable, Subscription\n\n1. Generally we need to use services to interact\n\n\u200B\t①First define a Subject variable\n\n\u200B\t②Then you need to convert the Subject in the definition of an Observable variable\n\n\u200B\t③Define a method for changing data\n\n```typescript\nisAuthenticated = new Subject();\n\nauthObservable = this.isAuthenticated.asObservable();\n\nemitAuth(auth: boolean) {\n    this.isAuthenticated.next(auth);\n    this.isAuth = auth;\n  }\n```\n\n2. Then we publish the data in the passed component\n\n```typescript\nthis.authService.emitAuth(true);\n```\n\n3. Receive data on Compoent subscription data\n\n```typescript\nprivate authSub: Subscription;\nisAuthenticated = false;\n\n  // Use subscribe to subscribe. When the data is transmitted, the result will be received here.\n    this.authSub = this.authService.authObservable.subscribe(auth => {\n      this.isAuthenticated = auth;\n    });\n  }\n```\n\n\n\n",
  "5ddd915c15d8863d8ea8b994": "# Init react\n\ncreate-react-app can help us bulid the app qulicky\n\n```\nnpx create-react-app client\n```\n\n# Start C/S together\n\nIf we are developing together in the background, we need to start two servers. Very troublesome, so how to start the rescue and node services at the same time?\n\n1.\n\n```\nnpm install --save concurrently\n```\n\n2.\n\nin server side package.json add some code in scripts. Please notice that the client must under server.\n\n```javascript\n\"scripts\": {\n    \"start\": \"node index.js\",\n    \"server\": \"nodemon index.js\",\n    \"client\": \"npm run start --prefix client\",\n    \"dev\": \"concurrently \\\"npm run server\\\" \\\"npm run client\\\"\"\n  }\n```\n\n3. try to run\n\n```\nnpm run dev\n```\n\n# Proxy\n\n```html\n<a href=\"/auth/google\">\n```\n\nIf our react port is 3000, we click the link, it should be http://localhost:300/auth/google.\n\nBut we want to give the request to server. So in this case, we need to use proxy.\n\n1.\n\n```\nnpm install http-proxy-middleware --save\n```\n\n2. create a js file under client\n\n```javascript\nconst proxy = require('http-proxy-middleware');\n\nmodule.exports = function(app) {\n    app.use(proxy(['/api', '/auth/google'], { target: 'http://localhost:5000' }));\n};\n```\n\nIn fact, we give the url http://localhost:300/auth/google to server. in other word, the client give server proxy.",
  "5ddd91f1c592802802d6887f": "# Router\n\n## react-router-dom\n\nFragment is an outermost frame, which can be regarded as the outermost <div>\n\nBrowserRouter only uses this for internal routing\n\nSwitch is literally\n\nRoute according to different paths and components\n\n```javascript\nimport React, {Fragment} from 'react';\nimport {BrowserRouter, Route, Switch} from 'react-router-dom';\nimport './App.css';\n\nimport Navbar from \"./components/layout/Navbar\";\nimport Landing from \"./components/layout/Landing\";\nimport Register from \"./components/auth/Register\";\nimport Login from \"./components/auth/Login\";\n\nconst App = () =>\n    <BrowserRouter>\n        <Fragment>\n            <Navbar/>\n            <Route exact path='/' component={Landing}/>\n            <section className=\"container\">\n                <Switch>\n                    <Route exact path='/register' component={Register}/>\n                    <Route exact path='/login' component={Login}/>\n                </Switch>\n            </section>\n        </Fragment>;\n    </BrowserRouter>\nexport default App;\n\n```\n\n## PrivateRoute\n\nIt is same like a interceptor, take any unauthentcated request to login route.\n\n```javascript\n/**\n * Created by Kaizhi Du on 2019/11/7.\n */\nimport React from 'react';\nimport {Route, Redirect} from 'react-router-dom';\nimport {connect} from \"react-redux\";\n\nconst PrivateRoute = ({component: Component, auth, ...rest}) => (\n    <Route\n        {...rest}\n        render={props =>\n                // if is not authenticated, we redicect to login route\n            !auth.isAuthenticated ? (\n                <Redirect to='/login'/>\n            ) : (\n                <Component {...props}/>\n                )\n        }\n    />\n);\n\nconst mapStateToProps = state => ({\n    auth: state.auth\n});\n\nexport default connect(mapStateToProps)(PrivateRoute);\n```\n\n# ",
  "5ddd92c10965800a5e70f107": "# Component State\n\nComponent state is a local parameter.\n\nWhen a component mount, the component state is init, we this component unmount, destroy it.\n\n```javascript\nclass SurveyNew extends Component {\n\n    // init the state\n    state = {showFormReview: false};\n\n    renderContent() {\n        // judge this. if true, send a prop to SurveyFormReview; else send a prop to SurveyForm\n        if (this.state.showFormReview) {\n            return <SurveyFormReview\n                onCancelClick={() => this.setState({showFormReview: false})}\n            />\n        }\n        return <SurveyForm\n            onFormSubmit={() => this.setState({showFormReview: true})}\n        />\n    }\n\n    render() {\n        return (\n            <div>\n                {this.renderContent()}\n            </div>\n        )\n    }\n}\n\nexport default reduxForm({\n    form: 'surveyForm'\n})(SurveyNew);\n```\n\n# Hooks\n\nwe use arrow function instead of class component\n\n```javascript\n/**\n * Created by mqd on 2019/11/5.\n */\nimport React, {Fragment, useState} from 'react';\nimport {Link} from \"react-router-dom\";\n\n// we use arrow function instead of class component\nconst Login = () => {\n    // it is component state\n    const [formData, setFormData] = useState({\n        email: '',\n        password: ''\n    });\n    // the email and password must match the value of form\n    const {email, password} = formData;\n\t// when email/password change, the formData will change\n    const onChange = e => setFormData({\n        ...formData, [e.target.name]: e.target.value\n    });\n\t// when user sumbit, we can see all the value of form\n    const onSubmit = e => {\n        e.preventDefault();\n        console.log(formData);\n    };\n\n    return <Fragment>\n        <h1 className=\"large text-primary\">Sign In</h1>\n        <p className=\"lead\"><i className=\"fas fa-user\"></i> Create Your Account</p>\n        <form className=\"form\" action=\"create-profile.html\" onSubmit={e => onSubmit(e)}>\n            <div className=\"form-group\">\n                <input type=\"email\" placeholder=\"Email Address\" name=\"email\" value={email} onChange={e => onChange(e)}/>\n                <small className=\"form-text\"\n                >This site uses Gravatar so if you want a profile image, use a\n                    Gravatar email\n                </small>\n            </div>\n            <div className=\"form-group\">\n                <input\n                    type=\"password\"\n                    placeholder=\"Password\"\n                    name=\"password\"\n                    minLength=\"6\"\n                    value={password} onChange={e => onChange(e)}\n                />\n            </div>\n            <input type=\"submit\" className=\"btn btn-primary\" value=\"Login\"/>\n        </form>\n        <p className=\"my-1\">\n            Do not have an account? <Link to=\"/register\">Sign Up</Link>\n        </p>\n    </Fragment>;\n};\n\nexport default Login\n```\n\n",
  "5ddd960e62fdae442ed43a8c": "# Create project\n\ngit init\n\nnpm init\n\n## Req and Res\n\n**req.body**  we can get the body information from req.body\n\n**req.params** we can get route path  information from req.params\n\n**res.send()** we can send a message use res.send()\n\n**res.json({})** we can send a json use res.json({})\n\n# Server validation\n\n```javascript\nconst {check, validationResult} = require('express-validator');\nrouter.post('/', authMiddleware,\n            // we define the role of validation in there\n    [\n        check('status', 'Status is required').not().isEmpty(),\n        check('skills', 'Skills is required').not().isEmpty()\n    ],\n    async (req, res) => {\n    // we can parse the req to validationResult, to check status and skills\n        const errors = validationResult(req);\n    // if there have error, the errors should not be expty\n        if (!errors.isEmpty()) {\n            return res.status(400).json({errors: errors.array()});\n        }\n```\n\n",
  "5ddd97650a5b5a467251c73a": "# mangoDB\n\n## 1. create the Atlas\n\nSign up a account, after sign up, we can create a cluster.\n\nwe need to create a user \n\nthen, choose connect your application and copy this code\n\nfinal add this code to key.js\n\n## 2. Schema\n\nUnder model, create new survey.js\n\nIf a survey corresponds to multiple Recipients, we can use an array to represent\n\nIf survey and user are one-to-one, we can use {type: Schema.Types.ObjectId, ref: 'User'} to represent\n\n```javascript\n//survey.js\nconst surveySchema = new Schema({\n    title: String,\n    body: String,\n    subject: String,\n    recipients: [RecipientSchema],\n    yes: {type: Number, default: 0},\n    no: {type: Number, default: 0},\n    dataSent: Date,\n    lastResponded: Date,\n    _user: {type: Schema.Types.ObjectId, ref: 'User'}\n});\n```\n\n```javascript\n//recipient.js\nconst recipientSchema = new Schema({\n    email: String,\n    responded: {type: Boolean, default: false}\n});\n```\n\n### Important Point\n\nIf we want to reference the ID of another schema in a schema:\n\n```javascript\n user: {\n        type: mongoose.Schema.Types.ObjectId,\n        ref: 'user'\n    },\n```\n\nIf we want to add another object to one object:\n\n```javascript\nuser: {\n    experience: [\n        {\n            title: {type: String, required: true},\n            company: {type: String, required: true},\n            location: {type: String},\n            from: {type: Date, required: true},\n            to: {type: Date},\n            current: {type: Boolean, default: false},\n            description: {type: String}\n        }\n    ]\n}\n```\n\n## 3. Mongoose\n\nCreate a new Schema\n\n```javascript\nconst Profile = require('../../models/Profile');\n\nprofile = new Profile({\n    xx: xx\n});\nprofile.save();\n```\n\nHow to change child objects in an object\n\n```javascript\nprofile.education.unshift(newEdu);\n```\n\nHow to delete an element of a child object in an object\n\n```javascript\nconst removeIndex = profile.education.map(item => item._id).indexOf(req.params.edu_id);\nprofile.education.splice(removeIndex, 1);\n```\n\nCheck if there is required data\n\n```javascript\n// check if the post has already been liked\n        if (post.likes.filter(like => like.user.toString() === req.user.id).length > 0) {\n            return res.status(400).json({msg: \"Post already liked\"});\n        }\n```\n\n",
  "5ddd9a7b0235f1469e89813d": "# Basic setup\n\nwe need a js file to write our store\n\n```javascript\n// store.js under src folder\nimport {createStore, applyMiddleware} from 'redux';\nimport {composeWithDevTools} from 'redux-devtools-extension';\nimport thunk from 'redux-thunk';\nimport rootReducer from './reducers';\n\nconst initialState = {};\n\nconst middleware = [thunk];\n\nconst store = createStore(rootReducer, initialState, composeWithDevTools(applyMiddleware(...middleware)));\n\nexport default store;\n```\n\nin our app component, we need to import store, and use the Provider to wrap all the code\n\n```javascript\n// Redux\n// Redux and react is separate, we use react-redux combine together\nimport {Provider} from 'react-redux';\nimport store from './store';\n\n<Provider store={store}>\n    .....\n    </Provider>\n```\n\n",
  "5ddd9b16ffd6cd1cd6d247a7": "## 1. Define the backend router\n\nA set of surveys is retrieved from the database via the previously defined model and is ready to be returned to the frontend via res.send().\n\n```javascript\n app.get('/api/surveys', requireLogin, async (req, res) => {\n        const surveys = await Survey.find({_user: req.user.id});\n        res.send(surveys);\n    });\n```\n\n## 2. Define action\n\nDefine type, here is the call to facilitate the reducer.\n\n```javascript\nexport const FETCH_SURVEYS = 'fetch_surveys';\n```\n\nDefine action creator, \n\nWe fetch the data from the backend through axios.\n\nsent to the reducer through the dispatch, which includes type (distinguish different actions) and payload (specific data)\n\n```javascript\nexport const fetchSurveys = () => async dispatch => {\n    const res = await axios.get('/api/surveys');\n    dispatch({type: FETCH_SURVEYS, payload: res.data})\n};\n```\n\n## 3. Define reducer\n\nFirst, you need to reference the type inside the action to distinguish which action is\n\nThen use switch to judge, if type is FETCH_SURVEYS, use payload to update redux state\n\n```javascript\nimport {FETCH_SURVEYS} from '../actions/type';\n\nexport default function (state = [], action) {\n    switch (action.type) {\n        case FETCH_SURVEYS:\n            return action.payload || false;\n        default:\n            return state;\n    }\n}\n\n```\n\nFinally, don't forget to add the new reducer to the combineReducer.\n\n```javascript\nexport default combineReducers({\n    auth: authReducer,\n    surveys: surveysReducer,\n    form: reduxFormReducer\n});\n```\n\n## ",
  "5ddd9b9e9b909afffd418894": "## Create component\n\ncreate a class\n\n```javascript\nclass SurveysList extends Component {\n          render() {\n        return (\n            <div>\n              \tSurveys\n            </div>\n        )\n    }\n}\n```\n\nimport the actions\n\n```javascript\nimport * as actions from \"../../actions\";\nclass SurveysList extends Component {\n        render() {\n        return (\n            <div>\n               Surveys\n            </div>\n        )\n    }\n}\n```\n\ncreate connect,and create mapStateToProps function.\n\nIf we want to render data to the page, we must use props, the use of mapStateToProps is to convert the data in the redux state to props.\n\nconnect need to connect with mapStateToProps,action,and class.\n\n```javascript\nimport React, {Component} from \"react\";\nimport {connect} from \"react-redux\";\nimport * as actions from \"../../actions\";\n\nclass SurveysList extends Component {\n\n    render() {\n        return (\n            <div>\n                Surveys\n            </div>\n        )\n    }\n}\n\nfunction mapStateToProps(state) {\n    return {surveys: state.surveys}\n}\n\nexport default connect(mapStateToProps, actions)(SurveysList);\n```\n\nThen we need to add lifecycle. componentDidMount is when the class is mounted, trigger action - fetchSurveys\n\n```javascript\nimport React, {Component} from \"react\";\nimport {connect} from \"react-redux\";\nimport * as actions from \"../../actions\";\n\nclass SurveysList extends Component {\n\n    componentDidMount() {\n        this.props.fetchSurveys();\n    }\n    \n    render() {\n        return (\n            <div>\n                Surveys\n            </div>\n        )\n    }\n}\n\nfunction mapStateToProps(state) {\n    return {surveys: state.surveys}\n}\n\nexport default connect(mapStateToProps, actions)(SurveysList);\n```\n\nThen we can get the data through this.props.surveys, and then we can render to the page. Usage is {xx.xx}\n\n```javascript\nimport React, {Component} from \"react\";\nimport {connect} from \"react-redux\";\nimport * as actions from \"../../actions\";\n\nclass SurveysList extends Component {\n\n    componentDidMount() {\n        this.props.fetchSurveys();\n    }\n\n    renderSurveys() {\n        return this.props.surveys.map(survey => {\n            return (\n                <div className=\"card darken-1\" key={survey._id}>\n                    <div className=\"card-content\">\n                         <span className=\"card-title\">\n                             {survey.title}\n                         </span>\n                        <p>\n                            {survey.body}\n                        </p>\n                        <p className=\"right\">\n                            Send on: {survey.dateSent}\n                        </p>\n                    </div>\n                </div>\n            )\n        });\n    }\n\n    render() {\n        return (\n            <div>\n                {this.renderSurveys()}\n            </div>\n        )\n    }\n}\n\nfunction mapStateToProps(state) {\n    return {surveys: state.surveys}\n}\n\nexport default connect(mapStateToProps, actions)(SurveysList);\n```\n\n# ",
  "5ddd9f7e487b57423a94306a": "# Define redux-form reducer\n\nredux-form take the reducer by itself, so we only need to invoke it.\n\n```javascript\nimport {combineReducers} from \"redux\";\nimport {reducer as reduxFormReducer} from \"redux-form\";\nimport authReducer from \"./authReducer\";\n\nexport default combineReducers({\n    auth: authReducer,\n    form: reduxFormReducer\n});\n```\n\n# Define the template of Field\n\nFields that use SurveyField will follow the rules below.\n\n```javascript\nimport React from \"react\";\n// input is come form props.input\nexport default ({input, label}) => {\n    return (\n        <div>\n            <label>{label}</label>\n            <input {...input} />\n        </div>\n    )\n}\n```\n\n# ",
  "5ddd9fbfb2760ed5cd2fd292": "# Redux-form\n\n```javascript\nimport _ from 'lodash';\nimport React, {Component} from \"react\";\nimport {reduxForm, Field} from \"redux-form\";\nimport SurveyField from \"./SurveyField\";\nimport {Link} from \"react-router-dom\";\n\n// when we change the input, the redux-form will auto save the data to redux store\n// this.props.handleSubmit is provide by reduxForm\n// SurveyField is a template of Field\n\nconst FIELDS = [\n    {label: 'Survey Title', name: 'surveyTitle'},\n    {label: 'Survey Line', name: 'surveyLine'},\n    {label: 'Email Body', name: 'emailBody'},\n    {label: 'Recipient List', name: 'recipientList'}\n];\n\nclass SurveyForm extends Component {\n\n    // We loop the FIELDS to call the Field template SurveyField.\n    renderFields() {\n        return _.map(FIELDS, ({label, name}) => {\n            return <Field type=\"text\" label={label} name={name} component={SurveyField}/>\n        });\n    }\n\n    render() {\n        return (\n            <div>\n                <form onSubmit={this.props.handleSubmit(values => console.log(values))}>\n                    {this.renderFields()}\n                    <Link to='/surveys' className='red btn-flat white-text'>\n                        Cancel\n                    </Link>\n                    <button className='btn btn-info right' type='submit'>\n                        Next\n                        <i className='material-icons right'>done</i>\n                    </button>\n                </form>\n            </div>\n        );\n    }\n}\n\n// It's very similar to redux, we need to set the name to surveyForm to be redux-form\nexport default reduxForm({\n    form: 'surveyForm'\n})(SurveyForm);\n```\n\n",
  "5ddd9ff92b76df2496730941": "# Validation\n\nFirst of all, we need to add validate to reduxForm\n\n```javascript\nexport default reduxForm({\n    validate,\n    form: 'surveyForm'\n})(SurveyForm);\n```\n\nThen, we need to create a function named vaildate\n\n```javascript\n// the values is the object coming from our form\n// error is metaData from our form\nfunction validate(values) {\n    const errors = {};\n\n    errors.recipientList = validateEmails(values.recipientList || '');\n\n    if (!values.surveyTitle) {\n        errors.surveyTitle = \"You must provide a title\";\n    }\n    if (!values.surveyLine) {\n        errors.surveyLine = \"You must provide a survey line\";\n    }\n    if (!values.emailBody) {\n        errors.emailBody = \"You must provide a email body\";\n    }\n    if (!values.recipientList) {\n        errors.recipientList = \"You must provide at least one recipient\";\n    }\n\n    return errors;\n}\n```\n\nin our Field template,we need to let our form show the error.\n\n```javascript\nimport React from \"react\";\n// input is come form props.input\n// meta is html metadata\n// {touched && error} mean if you have error or touch , this message will show.\nexport default ({input, label, meta: {error, touched}}) => {\n    return (\n        <div>\n            <label>{label}</label>\n            <input style={{marginBottom: '5px'}} {...input} />\n            <div className=\"red-text\">\n                {touched && error}\n            </div>\n        </div>\n    )\n}\n```\n\n",
  "5de6e381150b2c26b40e1b58": "# Initialize\n\n## Initialize (Server)\n\nFirst we need to create a file named ***.gitignore***\n\nthen\n\n```\ngit init\nnpm init\n```\n\nand we should install some common dependencies\n\n```\nnpm i express express-validator bcryptjs config gravatar jsonwebtoken mongoose request\n```\n\nafter that，we should build a index.js to start our project。But before that we need to build our mongoDB. \n\nwe also need to build a file to store all the key or connect we need.\n\n```javascript\nmodule.exports = {\n  mongoURI: 'mongodb+srv://admin-kevin:2wnKt6CRkwyMbngV@emily-o9czr.mongodb.net/kaizhidu?retryWrites=true&w=majority',\n  JWTSecret: 'xxxxxxxxxxxxxxxxxx',\n  githubClientId: 'xxxxxxxxxxxxx',\n  githubSecret: 'xxxxxxxxxxxxxxxxx'\n};\n```\n\nthis is database config file\n\n```javascript\nconst mongoose = require('mongoose');\nconst config = require('./default');\n\nconst connectDB = async () => {\n    try {\n        await mongoose.connect(config.mongoURI, {\n            useNewUrlParser: true,\n            useCreateIndex: true,\n            useFindAndModify: false\n        });\n    } catch (err) {\n        console.log(err);\n        // Exit process with failure\n        process.exit(1);\n    }\n};\nmodule.exports = connectDB;\n```\n\nfinally, we need a index.js file to integrate all the configuration, and start the project.\n\n```javascript\nconst express = require('express');\nconst connectDB = require('./config/db');\n\nconst app = express();\n\n// connect database\nconnectDB();\n\n// init middleware\n// we can use req.body because code below\napp.use(express.json({extended: false}));\n\napp.get('/', (req, res) => res.send('API RUNNING...'));\n\nconst PORT = process.env.PORT || 5000;\n\napp.listen(PORT, () => console.log(`Server start on port ${PORT}`));\n```\n\n## ",
  "5de6e9b7fb7e5f277cdc584b": "## Initialize (Client)\n\ncreate react\n\n```\nnpx create-react-app client\n```\n\nthen, put client/node_modules to server's ***.gitignore*** \n\nafter that，we need to install some common dependencies\n\n```\nnpm i axios react-router-dom redux react-redux redux-thunk redux-form redux-devtools-extension moment react-moment uuid prop-types\n```\n\nWe now have a server and a client, and we want to run them together every time, so we need to add the following two pieces of code to the server's *** package.json ***:\n\n```json\n\"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"server\": \"nodemon index.js\",\n    \"client\": \"npm run start --prefix client\",\n    \"babao\": \"concurrently \\\"npm run server\\\" \\\"npm run client\\\"\"\n  },\n \"devDependencies\": {\n    \"concurrently\": \"^5.0.0\",\n    \"nodemon\": \"^1.19.4\"\n  }\n```\n\nBecause our project is separated from the front end, we need to use proxy. Put the following code in *** client / package.json ***\n\n```javascript\n  \"proxy\": \"http://localhost:5000\"\n```\n\nFinally,  npm run babao， we can run C/S together.\n\n## ",
  "5de6eb5d37e1763728713cc5": "## Initialize (Redux)\n\nFirst we need to create ***actions***, ***type.js*** \n\nthen create ***reducers***， below is  ***index.js *** for combine all the reducer\n\n```javascript\nimport {combineReducers} from \"redux\";\nexport default combineReducers({\n    \n});\n```\n\nafter that, we need to set our ***store.js***\n\n```javascript\nimport { createStore, applyMiddleware } from 'redux';\nimport { composeWithDevTools } from 'redux-devtools-extension';\nimport thunk from 'redux-thunk';\nimport rootReducer from './reducers';\n\nconst initialState = {};\n\nconst middleware = [ thunk ];\n\nconst store = createStore(rootReducer, initialState, composeWithDevTools(applyMiddleware(...middleware)));\n\nexport default store;\n```\n\nthen, we need to load the <Provider /> in our Provider\n\n```javascript\nimport React, {Fragment, useEffect} from 'react';\nimport {BrowserRouter, Route, Switch} from 'react-router-dom';\nimport './App.css';\n// Redux\n// Redux and react is separate, we use react-redux combine together\nimport {Provider} from 'react-redux';\nimport store from './store';\n\nconst App = () => {\n\n    useEffect(() =>{\n        store.dispatch(loaderUser());\n    },[]);\n\n    return (\n        <Provider store={store}>\n            <BrowserRouter>\n                <Fragment>\n                    This is APP\n                </Fragment>\n            </BrowserRouter>\n        </Provider>\n    );\n};\n\n\nexport default App;\n\n```\n\n## Initialize (Style Framework)\n\nwe choose bootstrap as our css framework\n\n```\nnpm install react-bootstrap bootstrap\n```\n\nthen, we should invoke below to our ***src/index.js*** \n\n```javascript\nimport 'bootstrap/dist/css/bootstrap.min.css';\n```\n\nwe also need to invoke bootstrap in our ***index.html*** \n\nbecause I need use some icon from fontawesome, so invoke it as well\n\n```html\n    <link\n            rel=\"stylesheet\"\n            href=\"https://maxcdn.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css\"\n            integrity=\"sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T\"\n            crossorigin=\"anonymous\"\n    />\n    <link\n            rel=\"stylesheet\"\n            href=\"https://use.fontawesome.com/releases/v5.8.1/css/all.css\"\n            integrity=\"sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf\"\n            crossorigin=\"anonymous\"\n    />\n```\n\n# ",
  "5de6f45065acb0458cc24c60": "## Register User (Server)\n\n### Set model\n\n```javascript\nconst mongoose = require('mongoose');\n\nconst UserSchema = new mongoose.Schema({\n    name: { type: String, required: true },\n    email: { type: String, required: true },\n    password: { type: String, required: true, unique: true },\n    avatar: {type: String},\n    date: {type: String, default: Date.now}\n});\n\nmodule.exports = User = mongoose.model('user', UserSchema);\n```\n\n### Set route\n\nFirst of all, we need to write inside ***index.js*** ：\n\n```javascript\napp.use('/api/user', require('./routes/api/user'));\n```\n\nok, we have prefix now，if we write '/' in our user route，is './api/user'\n\nbelow is user route\n\nWe use validation. If there is a validation error, an error message will be prompted to the front desk. Of course, we can validate at front end.\n\nJson Web Token is a combination of userid, expiretime, and JWTSecret, and then forms a long password, which can be used for login verification and other situations.\n\nWith the error, we need to use  ***return res.status (500) .json ({error: [{msg: 'User already exists!'}]});***  Send it back to the frontend.\n\n```javascript\nconst express = require('express');\nconst router = express.Router();\nconst { check, validationResult } = require('express-validator');\nconst gravatar = require('gravatar');\nconst bcrypt = require('bcryptjs');\nconst jwt = require('jsonwebtoken');\nconst config = require('../../config/default');\n\nconst User = require('../../models/User');\n\n// router POST api/user\n// Register user\nrouter.post('/', [\n    check('name', 'Name is required').not().isEmpty(),\n    check('email', 'Please include a valid email').isEmail(),\n    check('password', 'Please enter a password with 6 or more characters').isLength({ min: 6 })\n], async (req, res) => {\n    const errors = validationResult(req);\n    if (!errors.isEmpty()) {\n        return res.status(400).json({ errors: errors.array() });\n    }\n    const { name, email, password } = req.body;\n    try {\n        let user = await User.findOne({ email });\n        if (user) {\n            return res.status(500).json({ error: [ { msg: 'User already exists!' } ] });\n        }\n        // Get user gravatar\n        const avatar = gravatar.url(email, {\n            s: '200',\n            r: 'pg',\n            d: 'mm'\n        });\n        // Create user info\n        user = new User({\n            email,\n            name,\n            avatar,\n            password\n        });\n        // Encrypt password\n        const salt = await bcrypt.genSalt(10);\n        user.password = await bcrypt.hash(password, salt);\n        // save the user to database\n        await user.save();\n        //Return jsonwebtoken(JWT)\n        const payload = {\n            user: {\n                id: user.id\n            }\n        };\n        jwt.sign(\n            payload,\n            config.JWTSecret,\n            { expiresIn: 360000 },\n            (err, token) => {\n                if (err) throw err;\n                res.json({ token: token });\n            }\n        )\n    } catch (err) {\n        console.error(err.message);\n        res.status(500).send('Server Errors');\n    }\n});\n\nmodule.exports = router;\n\n```\n\n",
  "5de6f51071fd381bec4473d1": "We use redux-form to easily operate our form\n\nSince we do not need too much registration information, we intend to use a page to display registration and login, so we use ***const [register, setRegister] = useState (false);*** in *** auth.js *** to determine Registration or Login\n\n```javascript\n/**\n * Created by Kaizhi Du on 2019/11/14.\n */\nimport React, { Fragment, useState } from 'react';\nimport { connect } from \"react-redux\";\nimport { Modal } from \"react-bootstrap\";\nimport Register from \"./Register\";\nimport Login from \"./Login\";\n\nconst Auth = () => {\n\n    const [ register, setRegister ] = useState(false);\n\n    const registerSubmit = (values) => {\n        console.log(values);\n    };\n\n    const loginSubmit = (values) => {\n        console.log(values);\n    };\n\n    // If register is true show <Register>, else show <Login>\n    return (\n        <Fragment>\n            <Modal.Header closeButton>\n                <Modal.Title>{register ? 'Register' : 'Login'}</Modal.Title>\n            </Modal.Header>\n            <Modal.Body>\n                {register ?\n                    (\n                        <Register onSubmit={registerSubmit}/>\n                    )\n                    :\n                    (\n                        <Login onSubmit={loginSubmit}\n                            onRegisterClick={() => setRegister(true)}/>\n                    )\n                }\n            </Modal.Body>\n        </Fragment>\n    )\n}\n\nexport default connect(null, {})(Auth);\n```\n\nSince registration and login are similar, I only show the registration page\n\nwe must add   touchOnChange: true, otherwise, touched can not work\n\nwe also can set validate，return errors. redux-form can help us to judge it\n\nhandleSubmit is come from redux-form\n\n```javascript\n/**\n * Created by Kaizhi Du on 2019/11/13.\n */\nimport React, { Fragment } from 'react';\nimport { Button, Col, Form } from \"react-bootstrap\";\nimport { reduxForm, Field } from \"redux-form\";\nimport FieldInput from \"../../utils/FieldInput\";\nconst emailRg = /^[a-zA-Z0-9.!#$%&’*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*$/;\n\nconst Register = ({ handleSubmit }) => {\n    return (\n        <Fragment>\n        \t// when you click submit, reudx-from will toggle the handlesubmit send the data to auth.js\n            <Form onSubmit={handleSubmit}>\n                <Form.Group controlId=\"name\">\n                    <Form.Label>Name</Form.Label>\n                    <Field name=\"name\" type=\"text\" placeholder=\"User name\" component={FieldInput} autocomplete=\"off\"/>\n                </Form.Group>\n                <Form.Group controlId=\"email\">\n                    <Form.Label>Email address</Form.Label>\n                    <Field type=\"email\" name=\"email\" placeholder=\"Enter email\" component={FieldInput} autocomplete=\"off\"/>\n                </Form.Group>\n                <Form.Group controlId=\"password\">\n                    <Form.Label>Password</Form.Label>\n                    <Field type=\"password\" name=\"password\" placeholder=\"Password\" component={FieldInput} autocomplete=\"off\"/>\n                </Form.Group>\n                <Form.Group controlId=\"password2\">\n                    <Form.Label>Re-enter Password</Form.Label>\n                    <Field type=\"password\" name=\"password2\" placeholder=\"Please type your password again\"\n                           component={FieldInput} autocomplete=\"off\"/>\n                </Form.Group>\n                <Col className=\"text-right\">\n                    <Button variant=\"success\" type=\"submit\">\n                        Submit\n                    </Button>\n                </Col>\n            </Form>\n        </Fragment>\n    );\n};\n\nconst validate = (values) => {\n    const errors = {};\n    if (!values.name) errors.name = 'User\\'s name is required';\n    if (emailRg.test(values.email) === false) {\n        errors.email = 'This Email is invalid';\n    }\n    if (!values.password) errors.password = 'Password is required';\n    if (values.password !== values.password2) errors.password2 = 'Two password inputs must be consistent';\n    return errors;\n};\n\nexport default reduxForm({\n    validate,\n    touchOnChange: true,\n    form: 'RegisterForm'\n})(Register);\n```\n\nWe also need an InputField template to transmit each input tag\n\n```javascript\nimport React, { Fragment } from \"react\";\nimport { FormControl } from \"react-bootstrap\";\n// if touched is true and error have msg, we show the error message.\nconst FieldInput = ({ input, type, placeholder, name, meta }) => {\n    return (\n        <Fragment>\n            <FormControl\n                type={type}\n                name={name}\n                placeholder={placeholder}\n                value={input.value}\n                onChange={input.onChange}/>\n        <div className='text-danger'>\n            {meta.touched && meta.error}\n        </div>\n        </Fragment>\n\n    )\n};\n\nexport default FieldInput;\n\n```\n\n",
  "5de6f5d02c22564f40ddb5c0": "### Async validate\n\nWe want to dynamically check if the user exists when entering email\n\nWe need to use redux-form's asyncValidate\n\n```javascript\n/**\n * Created by Kaizhi Du on 2019/11/13.\n */\nimport React, { Fragment, useEffect } from 'react';\nimport { Button, Col, Form } from \"react-bootstrap\";\nimport { reduxForm, Field } from \"redux-form\";\nimport FieldInput from \"../../utils/FieldInput\";\nimport { getAllUser } from '../../actions/auth';\nimport { connect } from 'react-redux';\nimport store from '../../store';\n\nconst emailRg = /^[a-zA-Z0-9.!#$%&’*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*$/;\nlet allUsers = [];\n\nconst Register = ({ handleSubmit, users }) => {\n    // get all the user's email and push to allUsers\n    if (users) {\n        users.map(user => {\n            allUsers.push(user.email);\n        });\n    }\n\n    // when component mount, we get all the user\n    useEffect(() => {\n        store.dispatch(getAllUser());\n    }, []);\n\n    return (\n        <Fragment>\n            <Form onSubmit={handleSubmit}>\n               .......\n            </Form>\n        </Fragment>\n    );\n};\n\n// when every change in email, we check the email. if user in allUsers. we show the error\nconst sleep = ms => new Promise(resolve => setTimeout(resolve, ms));\nconst asyncValidate = (values) => {\n    return sleep(1000).then(() => {\n        if (allUsers.includes(values.email)) {\n            throw { email: 'That email is taken' }\n        }\n    });\n};\n\nconst validate = (values) => {\n    const errors = {};\n    if (!values.name) errors.name = 'User\\'s name is required';\n    if (emailRg.test(values.email) === false) {\n        errors.email = 'This Email is invalid';\n    }\n    if (!values.password) errors.password = 'Password is required';\n    if (values.password !== values.password2) errors.password2 = 'Two password inputs must be consistent';\n    return errors;\n};\n\nconst mapStateToProps = (state) => ({\n    users: state.auth.users\n});\n\n// if we want to use the connect with reduxForm we need to use () wrap all the reduxForm\nexport default connect(mapStateToProps, { getAllUser })(reduxForm({\n    validate,\n    asyncValidate,\n    touchOnChange: true,\n    asyncChangeFields: [ 'email' ],\n    form: 'RegisterForm'\n})(Register))\n```\n\nget all the user (api)\n\n```javascript\n// router GET api/user/all\n// get all the users\nrouter.get('/all', async (req, res) => {\n    const users = await User.find();\n    if (users) await res.json(users);\n    return await res.send(null);\n});\n```\n\nget all the user (action)\n\n```javascript\nexport const getAllUser = () => async dispatch => {\n    const res = await axios.get('/api/user/all');\n    dispatch({\n        type: GET_USERS,\n        payload: res.data\n    })\n};\n```\n\nget all the user (reducer)\n\n```javascript\ncase GET_USERS:\n            return {\n                ...state,\n                users: payload\n            };\n```\n\n",
  "5de6ffc48ea11f506cc04fe1": "### Register\n\nregister user (action)\n\nwe need to set hearder as application/json\n\nThen you need to convert the received JavaScript object into a string\n\n```javascript\nexport const register = ({ name, email, password }) => async dispatch => {\n    const config = {\n        headers: {\n            'Content-Type': 'application/json'\n        }\n    };\n    const body = JSON.stringify({ name, email, password });\n    try {\n        const res = await axios.post('/api/user', body, config);\n        dispatch({\n            type: REGISTER_SUCCESS,\n            payload: res.data\n        });\n    } catch (err) {\n        console.log(err.message);\n    }\n};\n```\n\nregister user (reducer)\n\nTo set a token to record login data in the application\n\n```javascript\ncase REGISTER_SUCCESS:\n            localStorage.setItem('token', payload.token);\n            return {\n                ...state,\n                user: payload,\n                loading: false,\n                isAuthenticated: true\n            };\n```\n\nin component， ***auth.js*** create a function ***registerSubmit***。when component ***Register*** form submit，call the ***registerSubmit*** \n\n```javascript\nconst registerSubmit = (values) => {\n\n        const { name, email, password } = values;\n        register({ name, email, password });\n    };\n\n\n<Register onSubmit={registerSubmit}/>\n```\n\n## ",
  "5de7006024d22254300ce115": "## Load user\n\nSince we need to record the information of the user after login and judge the permission information, after the user successfully logs in, a load user operation is required.\n\nWe need a middleware to find out if a token exists. If a token exists, decode this token into user information, and finally assign this to req.user\n\n```javascript\nconst jwt = require('jsonwebtoken');\nconst config = require('../config/default');\n\nmodule.exports = function (req, res, next) {\n    // Get token from header\n    const token = req.header('x-auth-token');\n\n    // Check if not token\n    if (!token) {\n        return res.status(401).json({msg:'No token, authorization denied'});\n    }\n    // Verify token\n    try {\n        const decoded = jwt.verify(token, config.JWTSecret);\n        // in other place, we can use the req.user fetch current user information\n        req.user = decoded.user;\n        // you must give the next() at the end, else you can not use this middleware\n        next();\n    }catch (err) {\n        res.status(401).json({msg: 'Token is not valid'});\n    }\n};\n\n```\n\nBecause we need to check the currently logged in user at any time and determine whether the user has permission to operate this request，so we need to use ***authMiddleware***\n\n```javascript\nconst express = require('express');\nconst router = express.Router();\n\nconst User = require('../../models/User');\nconst authMiddleware = require('../../middleware/authMiddleware');\n\n// router GET api/auth\n// get current user\nrouter.get('/', authMiddleware, async (req, res) => {\n    try {\n        // req.user is create by authmiddle\n        const user = await User.findById(req.user.id).select('-password');\n        res.send(user);\n    } catch (err) {\n        res.status(500).send('Server error');\n    }\n});\n\nmodule.exports = router;\n\n```\n\nServer is set up, now back to the client:\n\nwe need a util : If token exist, we need to set token to web's header\n\n```javascript\nimport axios from 'axios';\nconst setAuthToken = (token) => {\n  if (token) {\n      axios.defaults.headers.common['x-auth-token'] = token;\n  } else {\n      delete axios.defaults.headers.common['x-auth-token']\n  }\n};\n\nexport default setAuthToken;\n```\n\nok, now we need to write an auth action, fetch the user info\n\n```javascript\nexport const loadUser = () => async dispatch => {\n    // we need to judge the token every action\n    if (localStorage.token) {\n        setAuthToken(localStorage.token);\n        try {\n            const res = await axios.get('/api/auth');\n            dispatch({\n                type: LOAD_USER,\n                payload: res.data\n            });\n        } catch (err) {\n            console.error(err.message);\n        }\n    }\n};\n```\n\nthen auth reducer, update redux state\n\n```javascript\ncase LOAD_USER:\n            return {\n                ...state,\n                user: payload,\n                isAuthenticated: true,\n                loading: false\n            };\n```\n\nWe need to load the user to redux and add the token to the header each time the page is rendered.\n\nSo we need to call loadUser everytime in <app />\n\n```javascript\nimport store from \"./store\";\nimport { loadUser } from \"./actions/auth\";\n\nfunction App() {\n    useEffect(() => {\n        store.dispatch(loadUser());\n    }, []);\n}\n```\n\n## ",
  "5de700e4fc14c23ebc56836d": "### login\n\nThe idea of login is similar to register. We need to accept an email and password and go to the database to see if they match. If it fails, it returns error msg. If it succeeds, the password, id, expiredate, and secret are combined into a JWT. Then return to JWT\n\n```javascript\n// router post api/auth\n// check user login\nrouter.post('/', async (req, res) => {\n    const { email, password } = req.body;\n    try {\n        let user = await User.findOne({ email: email });\n        if (!user) {\n            return res.status(500).json({ errors: [ { msg: 'user is not exist' } ] });\n        }\n        const isMatch = await bcrypt.compare(password, user.password);\n        if (!isMatch) {\n            return res.status(500).json({ errors: [ { msg: 'Invalid Credentials' } ] });\n        }\n        const payload = {\n            user: {\n                id: user.id\n            }\n        };\n        jwt.sign(\n            payload,\n            config.JWTSecret,\n            { expiresIn: 360000 },\n            (err, token) => {\n                if (err) throw err;\n                res.json({ token });\n            });\n\n    } catch (err) {\n        console.error(err.message);\n        res.status(500).send('Server error');\n    }\n});\n```\n\nthen code the login action,\n\nServer send the ***res.status(500).json({ errors: xxx })***\n\nclient reveive the error message:  ***const errors = err.response.data.errors***\n\n```javascript\nexport const login = ({ email, password }) => async dispatch => {\n    const config = {\n        headers: {\n            'Content-Type': 'application/json'\n        }\n    };\n    const body = JSON.stringify({ email, password });\n    try {\n        const res = await axios.post('/api/auth', body, config);\n        dispatch({\n            type: LOGIN_SUCCESS,\n            payload: res.data\n        });\n        // when you login success, you need to loadUser again\n        dispatch(loadUser());\n    } catch (err) {\n        const errors = err.response.data.errors;\n        console.log(errors[0].msg);\n        alert(errors[0].msg);\n    }\n};\n```\n\nthen, we code the login reducer,\n\nWe found the same state as returned by REGISTER_SUCCESS, so........\n\n```javascript\ncase LOGIN_SUCCESS:\ncase REGISTER_SUCCESS:\n            localStorage.setItem('token', payload.token);\n            return {\n                ...state,\n                user: payload,\n                loading: false,\n                isAuthenticated: true\n            };\n```\n\nFinally , we need to trigger action login in component/auth.js \n\n```javascript\nconst loginSubmit = (values) => {\n        const { email, password } = values;\n        login({ email, password });\n    };\n```\n\n### Logout\n\nCompared to register and login, logout is simple. We just need to set the action and reducer\n\nlogout action\n\n```javascript\nexport const logout = () => dispatch => {\n    dispatch({\n        type: LOG_OUT\n    });\n};\n```\n\nlogout reducer\n\nneed to remove token\n\n```javascript\ncase LOG_OUT:\n            localStorage.removeItem('token');\n            return {\n                ...state,\n                user: null,\n                token: null,\n                isAuthenticated: false,\n                loading: false\n            };\n```\n\nFinally, you just need to trigger the action logout when you click on logout.",
  "5de7255867fb603d94b907f5": "I learned a lot about web dev and summarized it into markdown notes. I now want to upload my notes to my personal webpage.\n\n## Note (Server)\n\n### Set model\n\nFirst，I need to design the schema\n\n```javascript\nconst mongoose = require('mongoose');\n\nconst NoteSchema = new mongoose.Schema({\n    title: { type: String, required: true },\n    content: { type: String, required: true },\n    types: [],\n    description: { type: String, default: \"As the title show\" },\n    publishDate: { type: Date, default: Date.now },\n    likes: [\n        {\n            user: {\n                type: mongoose.Schema.Types.ObjectId,\n                ref: 'users'\n            }\n        }\n    ],\n    comments: [\n        {\n            user: {\n                type: mongoose.Schema.Types.ObjectId,\n                ref: 'users'\n            },\n            text: { type: String, required: true },\n            date: { type: Date, default: Date.now },\n            secondComment: [\n                {\n                    user: {\n                        type: mongoose.Schema.Types.ObjectId,\n                        ref: 'users'\n                    },\n                    text: { type: String, required: true },\n                    date: { type: Date, default: Date.now }\n                }\n            ]\n        }\n    ]\n});\n\nmodule.exports = Note = mongoose.model('note', NoteSchema);\n```\n\n### Set route\n\nFirst designed to add notes, query all notes, and query a single note based on ID. Comment and secondary comments will be written later.\n\n```javascript\nconst express = require('express');\nconst router = express.Router();\nconst { check, validationResult } = require(\"express-validator/check\");\n\n// Note Schema\nconst Note = require('../../models/Note');\n\n// router POST api/note\n// create a note\nrouter.post('/', [\n        check('title', 'title is required').not().isEmpty(),\n        check('content', 'content is required').not().isEmpty(),\n        check('types', 'type is required').not().isEmpty()\n    ],\n    async (req, res) => {\n        const errors = validationResult(req);\n        if (!errors.isEmpty()) {\n            return res.status(400).json({ errors: errors.array() });\n        }\n        try {\n            const { title, content, types, publishDate } = req.body;\n            let saveType = [];\n            types.split(',').map(type =>{\n                saveType.push(type.trim());\n            });\n            const newNote = new Note({ title, content, types: saveType, publishDate });\n            const note = await newNote.save();\n            await res.json(note);\n        } catch (err) {\n            console.error(err.message);\n            res.status(500).send('Server error');\n        }\n    }\n)\n;\n\n// router GET api/note/all\n// get all the notes\nrouter.get('/all', async (req, res) => {\n    try {\n        const notes = await Note.find();\n        await res.json(notes);\n    } catch (err) {\n        console.error(err.message);\n        res.status(500).send('Server Error');\n    }\n});\n\n// router GET api/note/:id\n// get note by note id\nrouter.get('/:id', async (req, res) => {\n    try {\n        const note = await Note.findById(req.params.id);\n        if (!note) {\n            return res.status(500).send(\"No note found\");\n        }\n        await res.json(note);\n    } catch (err) {\n        console.error(err.message);\n        res.status(500).send(\"Server Error\");\n    }\n});\n\nmodule.exports = router;\n```\n\n## ",
  "5de726287b52423d1c9697e2": "### Set action\n\nset getNotes and getNote's action\n\n```javascript\n import axios from 'axios';\nimport { GET_NOTE, GET_NOTES } from \"./type\";\n\nexport const getNotes = () => async dispatch => {\n    try {\n        const res = await axios.get('/api/note/all');\n        dispatch({\n            type: GET_NOTES,\n            payload: res.data\n        });\n    } catch (err) {\n        console.log(err.message);\n    }\n};\n\nexport const getNote = (id) => async dispatch => {\n    console.log(id);\n    try {\n        const res = await axios.get(`/api/note/${id}`);\n        dispatch({\n            type: GET_NOTE,\n            payload: res.data\n        });\n    } catch (err) {\n        console.log(err.message);\n    }\n};\n```\n\n### Set reducer\n\nNote here that we need to have two loadings, one is the loading of notes, and the other is the loading of notes.\n\n```java\nimport { GET_NOTE, GET_NOTES } from \"../actions/type\";\n\nconst initialState = {\n    notes: [],\n    note: null,\n    loading: true,\n    noteLoading: true\n};\n\nexport default function(state = initialState, action) {\n    const { type, payload } = action;\n    switch (type) {\n        case GET_NOTES:\n            return {\n                ...state,\n                notes: payload,\n                note: null,\n                loading: false,\n                noteLoading: true\n            };\n        case GET_NOTE:\n            return {\n                ...state,\n                note: payload,\n                noteLoading: false,\n                loading: true\n            };\n        default:\n            return state;\n    }\n}\n\n```\n\n### ",
  "5de7275215c95d0d94169ce4": "### Note Component\n\nWe can extract notes in redux and display them on the page\n\nIf you need to pass values with parameters, use this method ***<Link to={`/note/${note._id}`}/ >***\n\nAlso remember that each map div must be distinguished by a key. Otherwise, although the program will not be wrong, the console will report an error\n\nI am used to use <Moment fromat='YYYY/MM/DD'>{note.publishDate}</Moment> to show the date data.\n\n```javascript\n/**\n * Created by Kaizhi Du on 2019/11/23.\n */\nimport React, { useEffect, Fragment } from 'react';\nimport { connect } from \"react-redux\";\nimport { getNotes } from '../../actions/note';\nimport { Col, Row, Badge } from \"react-bootstrap\";\nimport Moment from \"react-moment\";\nimport { Link } from \"react-router-dom\";\n\nconst NotesDisplay = ({ getNotes, note: { loading, notes } }) => {\n\n    useEffect(() => {\n        getNotes();\n    }, []);\n\n    return loading ? <div>Loading...</div>\n        :\n        (\n            <Fragment>\n                {\n                    notes.map(note => (\n                            <div key={note._id}>\n                                <Link to={'/note/${note._id}'} style={{ textDecoration: 'none', color: \"#310b13\" }}>\n                                    <h1>{note.title}</h1>\n                                </Link>\n                                <p>{note.description}</p>\n                                <Row>\n                                    {\n                                        note.types.map(type => {\n                                            return <Badge className=\"NoteLabel\" variant=\"info\">{type}</Badge>\n                                        })\n                                    }\n                                </Row>\n                                <Row>\n                                    <Col>\n                                        <div className=\"NoteDateText NoteDateLayout\">\n                                            <Moment fromat='YYYY/MM/DD'>{note.publishDate}</Moment>\n                                        </div>\n                                    </Col>\n                                    <Col>\n                                        <div className=\"text-right\">\n                                            <Link to={'/note/${note._id}'}>\n                                                <button className=\"btn btn-outline-info\">click here</button>\n                                            </Link>\n\n                                        </div>\n                                    </Col>\n                                </Row>\n                                <hr/>\n                            </div>\n                        )\n                    )\n                }\n            </Fragment>\n        )\n};\n\nconst mapStateToProps = (state) => ({\n    note: state.note\n});\n\nexport default connect(mapStateToProps, { getNotes })(NotesDisplay);\n```\n\nWhen we click on a single note, we will go to another page. We use match.params.id to get the id value in the url, and then pass it to NoteDisplay to display the single note information.\n\n```javascript\n/**\n * Created by Kaizhi Du on 2019/11/23.\n */\nimport React from 'react';\nimport { Badge, Col, Row } from \"react-bootstrap\";\nimport Moment from \"react-moment\";\n\nconst NoteDisplay = ({ note }) => {\n    return (\n        <div>\n            <h1>{note.title}</h1>\n            <p className=\"small\">{note.description}</p>\n            <hr/>\n            <p>{note.content}</p>\n            <hr/>\n            <Row>\n                {\n                    note.types.map(type => {\n                        return <Badge className=\"NoteLabel\" variant=\"info\">{type}</Badge>\n                    })\n                }\n            </Row>\n            <Row>\n                <Col>\n                    <div className=\"NoteDateText NoteDateLayout\">\n                        <Moment fromat='YYYY/MM/DD'>{note.publishDate}</Moment>\n                    </div>\n                </Col>\n                <Col>\n                </Col>\n            </Row>\n            <hr/>\n        </div>\n    )\n};\n\nexport default NoteDisplay\n```\n\n### Use markdown show \n\nBecause the format is incorrect, we need to use react-markdown and highlighter to beautify our notes.\n\n```\nnpm install --save react-markdown\nnpm install --save react-syntax-highlighter\n```\n\nNow we need to style the code block, we need to define a CodeBlock to use as a tool\n\n```javascript\nimport React, { PureComponent } from \"react\";\nimport PropTypes from \"prop-types\";\nimport { Prism as SyntaxHighlighter } from \"react-syntax-highlighter\";\n\nclass CodeBlock extends PureComponent {\n    static propTypes = {\n        value: PropTypes.string.isRequired,\n        language: PropTypes.string\n    };\n\n    static defaultProps = {\n        language: null\n    };\n\n    render() {\n        const { language, value } = this.props;\n        return (\n            <SyntaxHighlighter language={language} >\n                {value}\n            </SyntaxHighlighter>\n        );\n    }\n}\n\nexport default CodeBlock;\n\n```\n\nPracticing this is very simple, we just need to quote react-markdown.\n\nThen put the content in the source.\n\nFinally need renderers CodeBlock we defined above\n\n```javascript\nimport ReactMarkdown from \"react-markdown\";\nimport CodeBlock from \"../../utils/CodeBlock\";\nimport code from './noteContent';\n\nconst NoteDisplay = ({ note }) => {\n return (\n<ReactMarkdown\n                    source={code[note._id]}\n                    escapeHtml={false}\n                    renderers={{ code: CodeBlock }}\n                />\n  )\n};\n```\n\nThat is all,  pretty easy!",
  "5de727c48394230f0847a091": "## Comment (Server)\n\nReceived note id and user id. Then update the comments data in the note\n\n```javascript\n// router GET api/note/comment/:id/:userId\n// update the comment of note\nrouter.put('/comment/:id/:userId', async (req, res) => {\n    try {\n        const text = req.body.content;\n        const user = await User.findById(req.params.userId);\n        let note = await Note.findById(req.params.id);\n        const comment = {\n            avatar: user.avatar,\n            name: user.name,\n            text,\n            secondComments: []\n        };\n        note.comments.push(comment);\n        note = await note.save();\n        res.send(note);\n    } catch (err) {\n        console.error(err.message);\n        res.status(500).send(\"Server Error\");\n    }\n});\n\nmodule.exports = router;\n```\n\n## ",
  "5de72813f02ab333f0530da7": "### Set action\n\nIf you want to receive the data on the page, you must set the header: 'Content-Type': 'application / json'\n\nThen escape the received data with JSON.stringify\n\n```javascript\nexport const updateComment = ({ id, userId, content }) => async dispatch => {\n    const config = {\n        headers: {\n            'Content-Type': 'application/json'\n        }\n    };\n    const body = JSON.stringify({ content });\n    try {\n        const res = await axios.put(`/api/note/comment/${id}/${userId}`, body, config);\n        dispatch({\n            type: UPDATE_COMMENT,\n            payload: res.data\n        });\n    } catch (err) {\n        console.log(err.message);\n    }\n};\n```\n\n### Set reducer\n\nThe data to be returned is the same as GET_NOTE.\n\n```javascript\ncase UPDATE_COMMENT:\n        case GET_NOTE:\n            return {\n                ...state,\n                note: payload,\n                noteLoading: false,\n                loading: true\n            };\n```\n\n### ",
  "5de72897f4080906543eb6d6": "### Comment Component\n\nWe use redux-form to submit comment content and display it below the created textarea.\n\n```javascript\n/**\n * Created by Kaizhi Du on 2019/11/24.\n */\nimport React, { Fragment } from 'react';\nimport { Row, Media, Alert } from \"react-bootstrap\";\nimport { connect } from \"react-redux\";\nimport CreateComment from \"./CreateComment\";\nimport { updateComment } from \"../../../actions/note\";\nimport CommentsList from \"./CommentsList\";\n\nconst Comments = ({ updateComment, auth: { isAuthenticated, user }, note: { note, noteLoading } }) => {\n    const commentSubmit = (values) => {\n        const { content } = values;\n        const id = note._id;\n        const userId = user._id;\n        updateComment({ id, userId, content });\n    };\n\n    return (\n        <Fragment>\n            {\n                isAuthenticated ?\n                    (\n                        <Row>\n                            <Media style={{ \"marginBottom\": \"7px\" }}>\n                                <img\n                                    width={43}\n                                    height={43}\n                                    className=\"mr-3\"\n                                    src={user.avatar}\n                                    alt=\"Generic placeholder\"\n                                />\n                                <Media.Body>\n                                    <h5 style={{ \"marginTop\": \"7px\" }}>{user.name}</h5>\n                                </Media.Body>\n                            </Media>\n                            <CreateComment onSubmit={commentSubmit}/>\n                        </Row>\n                    ) :\n                    (\n                        <Row><Alert variant=\"warning\">You must log in before you comment</Alert></Row>\n                    )\n            }\n            <hr/>\n            <Row>\n                {\n                    noteLoading ?\n                        (\n                            <div>Loading...</div>\n                        )\n                        :\n                        (\n                            <ul className=\"list-unstyled\">\n                                <CommentsList comments={note.comments}/>\n                            </ul>\n                        )\n                }\n\n            </Row>\n        </Fragment>\n    )\n};\n\nconst mapStateToProps = (state) => ({\n    auth: state.auth,\n    note: state.note\n});\n\nexport default connect(mapStateToProps, { updateComment })(Comments);\n```\n\nWe want to clear the comment content when the submission is finished\n\n```javascript\nconst afterSubmit = (result, dispatch) =>\n    dispatch(reset('CommentForm'));\n\nexport default reduxForm({\n    validate,\n    touchOnChange: true,\n    form: 'CommentForm',\n    onSubmitSuccess: afterSubmit,\n})(CreateComment);\n```\n\nComments below the form\n\n```javascript\n/**\n * Created by Kaizhi Du on 2019/11/24.\n */\nimport React from 'react';\nimport { Media } from \"react-bootstrap\";\nconst CommentsList = ({ comments }) => {\n    return (\n        comments.map(comment => {\n            return <Media key={comment._id} as=\"li\">\n                <img\n                    width={32}\n                    height={32}\n                    className=\"mr-3\"\n                    src={comment.avatar}\n                    alt=\"Generic placeholder\"\n                />\n                <Media.Body>\n                    <h5>{comment.name}</h5>\n                    <p>{comment.text}</p>\n                </Media.Body>\n            </Media>\n        })\n    )\n};\n\nexport default CommentsList\n```\n\n## ",
  "5de72a2354405e4a5c893a3c": "## Like (Server)\n\nEach comment has an array likes []. We need to push userId in when it is like, and remove userId when it is not in like\n\n```javascript\n// router PUT api/note/comment/like/:noteId/:commentId/:userId\n// like a comment\nrouter.put('/comment/like/:noteId/:commentId/:userId', async (req, res) => {\n    try {\n        let note = await Note.findById(req.params.noteId);\n        const comments = note.comments;\n        comments.map(comment => {\n            if (comment._id == req.params.commentId) {\n                comment.likes.push(req.params.userId);\n            }\n        });\n        note = await note.save();\n        res.send(note);\n    } catch (err) {\n        console.error(err.message);\n        res.status(500).send(\"Server Error\");\n    }\n});\n```\n\n## Like (Client)\n\n### Set action\n\n```javascript\nexport const likeComment = ({ noteId, commentId, userId }) => async dispatch => {\n    const config = {\n        headers: {\n            'Content-Type': 'application/json'\n        }\n    };\n    try {\n        const res = await axios.put(`/api/note/comment/like/${noteId}/${commentId}/${userId}`, config);\n        console.log(res.data);\n        dispatch({\n            type: LIKE_COMMENT,\n            payload: res.data\n        });\n    } catch (err) {\n        console.error(err.message);\n    }\n};\n```\n\n### Component\n\nWhen you click the like icon, we call likeComment action\n\n```javascript\n <i\n                                    className=\"fas fa-thumbs-up\"\n                                    style={{ \"marginRight\": \"2px\" }}\n                                    onClick={() => like(comment._id)}\n                                ></i>\n```\n\n```javascript\nconst like = (commentId) => {\n        if (user === null) {\n            alert(\"You need to login first\");\n        } else {\n            const noteId = note._id;\n            const userId = user._id;\n            likeComment({ noteId, commentId, userId });\n        }\n    };\n```\n\n## ",
  "5de72b97502ab54564b46478": "## Pagination (Server)\n\n.skip () : to skip several elements\n\n.limit () : display several data starting from skip data\n\nI put skip and limit in req.body\n\n```javascript\n// router POST api/note/all/page\n// get all the notes with Pagination\nrouter.post('/all/page', async (req, res) => {\n    try {\n        const notes = await Note.find().sort({ publishDate: -1 }).skip(req.body.skip).limit(req.body.limit);\n        await res.json(notes);\n    } catch (err) {\n        console.error(err.message);\n        res.status(500).send('Server Error');\n    }\n});\n```\n\n## ",
  "5de72c47e86dd64928c5fa78": "## Pagination (Client)\n\n### Set action\n\nWe need to accept three data to update our redux-state\n\nskip，limit，和 active（current page）\n\n```javascript\nexport const getNotesWithPage = ({ skip, limit, active }) => async dispatch => {\n    console.log({ skip, limit, active });\n    const config = {\n        headers: {\n            'Content-Type': 'application/json'\n        }\n    };\n    const body = JSON.stringify({ skip, limit });\n    try {\n        const res = await axios.post('/api/note/all/page', body, config);\n        dispatch({\n            type: GET_NOTES_WITH_PAGE,\n            payload: { data: res.data, skip, active }\n        });\n    } catch (err) {\n        console.log(err.message);\n    }\n};\n```\n\n### Set reducer\n\nWe need to update our initialState to give initial values for skip, limit, and active\n\n```javascript\nconst initialState = {\n    notes: [],\n    note: null,\n    notesWithPage: [],\n    loading: true,\n    noteLoading: true,\n    notesWithPageLoading: true,\n    skip: 0,\n    limit: 5,\n    active: 1\n};\n```\n\nWe need to update the data passed by the payload\n\n```javascript\ncase GET_NOTES_WITH_PAGE:\n            return {\n                ...state,\n                notesWithPage: payload.data,\n                skip: payload.skip,\n                active: payload.active,\n                notesWithPageLoading: false\n            };\n```\n\n### Component\n\n```javascript\n/**\n * Created by Kaizhi Du on 2019/11/23.\n */\nimport React, { useEffect, Fragment } from 'react';\nimport { connect } from \"react-redux\";\nimport { getNotes, getNotesWithPage } from '../../actions/note';\nimport { Col, Row, Badge, Pagination } from \"react-bootstrap\";\nimport Moment from \"react-moment\";\nimport { Link } from \"react-router-dom\";\n\n// we need to get the skip, limit, and active from redux state\nconst NotesDisplay = ({ getNotes, getNotesWithPage, note: { loading, notes, notesWithPage, notesWithPageLoading, skip, limit, active } }) => {\n\n    useEffect(() => {\n        getNotes();\n        // after fetch all the notes, we need to get notes with page info (skip, limit, and active)\n        setTimeout(() => {\n            getNotesWithPage({ skip, limit, active });\n        }, 100);\n    }, []);\n\n    // after click the Pagination, we need to get the new page info (skip, limit, and active), and toggle the action getNotesWithPage\n    const changePage = (number) => {\n        const newSkip = (number - 1) * 5 + 1;\n        getNotesWithPage({ skip: newSkip, limit, active: number });\n    };\n\n    // count the total page\n    let totalPage = notes.length / 5 === 0 ? notes.length / 5 : notes.length / 5 + 1;\n    // not like java, js need to parseInt, then can get the int type\n    let intTotalPage = parseInt(Number(totalPage));\n    let items = [];\n    for (let number = 1; number <= totalPage; number++) {\n        items.push(\n            // click the Pagination toggle the function changePage\n            <Pagination.Item key={number} active={number === active} onClick={() => changePage(number)}>\n                {number}\n            </Pagination.Item>,\n        );\n    }\n\nconst mapStateToProps = (state) => ({\n    note: state.note\n});\n\nexport default connect(mapStateToProps, { getNotes, getNotesWithPage })(NotesDisplay);\n```\n\n# ",
  "5de72c871742cc11284c8cfd": "# Chart\n\n```\nnpm install --save react-chartjs-2 chart.js\n```\n\nI follow chartjs to write a language proficient chart, it is very simple\n\n```javascript\n/**\n * Created by Kaizhi Du on 2019/11/28.\n */\nimport React, { Component, Fragment } from 'react';\nimport { Radar } from 'react-chartjs-2';\nimport { Row } from \"react-bootstrap\";\n\nclass LanguageProficiency extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            languageData: {\n                labels: [ 'java', 'javascript', 'python', 'PHP', 'c' ],\n                datasets: [ {\n                    label: \"Language proficiency\",\n                    borderColor: \"rgba(122,197,205,0.8)\",\n                    pointBackgroundColor: \"rgba(122,197,205,0.8)\",\n                    backgroundColor: \"rgba(142,229,238,0.3)\",\n                    data: [ 80, 75, 50, 50, 60 ]\n                }, {}\n                ]\n            },\n        }\n    }\n\n    render() {\n        return (\n            <Fragment>\n                <br/>\n                <Row>\n                    <Radar\n                        width={600}\n                        height={320}\n                        data={this.state.languageData}\n                        options={{\n                            legend: {\n                                display: false\n                            },\n                            scale: {\n                                angleLines: {\n                                    display: false\n                                },\n                                pointLabels: { fontSize: 15 },\n                                ticks: {\n                                    suggestedMin: 20,\n                                    suggestedMax: 100,\n                                    fontSize: 13\n                                }\n                            }\n                        }}\n                    />\n                </Row>\n            </Fragment>\n\n        )\n    }\n}\n\nexport default LanguageProficiency\n```\n\n# ",
  "5de72dd794b9021f3471bc3c": "## 1. install passport\n\nWe need passport， help us oauth the google.\n\n```\nnpm install passport passport-google-oauth20@2 --save\n```\n\n```\nnpm install passport-google-oauth20@2 --save\n```\n\n## 2. create Google+\n\n(1) https://console.developers.google.com     create new project\n\n(2) enable the api and add the Google+\n\n(3) oauth consent screen, add the application name , then save\n\n(4) credentials -> create credential -> create oauth client id -> web application -> give the authorized and redirect URL\n\n(5)  Finally, you will get the Client ID and Client secret\n\n## 3. create key.js\n\ncreate a key.js store the information\n\n```javascript\nmodule.exports = {\n    googleClientID: 'xxxxxxxxxxxxxxxxxxxxxx',\n    googleClientSecret: 'xxxxxxxxxxxxxxxxxxxxxxx'\n}\n```\n\n## 4. passport\n\nserializeUser serializes the user.id in the environment into the session, ie the sessionID, and it will be stored as a credential in the user cookie.\n\ndeserializeUser is deserialized from the session. The parameter is the sessionID submitted by the user. If it exists, it queries the user from the database and stores it in req.user.\n\nWhen we use *** passport.use (new GoogleStrategy) ***, the information we want is in the profile. Then we need to check if a user exists through googleId, if not, register a new user, and then use the new user; if so, use the current user.\n\n```javascript\nconst GoogleStrategy = require('passport-google-oauth20').Strategy;\nconst key = require('../../config/default');\nconst passport = require('passport');\n\nconst User = require('../../models/User');\n\npassport.serializeUser((user, done) => {\n    done(null, user.id);\n});\n\npassport.deserializeUser(async (id, done) => {\n    User.findById(id)\n        .then((user) => {\n            done(null, user);\n        });\n});\n\npassport.use(new GoogleStrategy({\n        clientID: key.googleClientID,\n        clientSecret: key.googleClientSecret,\n        callbackURL: '/auth/google/callback',\n        proxy: true\n    }, async (accessToken, refreshToken, profile, done) => {\n        const existingUser = await User.findOne({ googleId: profile.id });\n        if (!existingUser) {\n            const user = await new User({\n                googleId: profile.id,\n                name: profile.displayName,\n                avatar: profile._json.picture,\n                password: profile.id+\"donotneed\"\n            }).save();\n            done(null, user);\n        }\n        done(null, existingUser);\n    })\n);\n```\n\n## 5. oauth route\n\nWhen the front station calls / auth / google, we need to use passport.authenticate. The ‘google’ parameter inside the system will automatically identify the strategy in the passport.\n\nWhen Google logs in, it will return a callback. We also need a router to accept / auth / google / callback\n\nWe also need to have 2 methods to get the current google user and log out\n\n```javascript\nconst express = require('express');\nconst passport = require('passport');\n\nmodule.exports = (app) => {\n    app.get('/auth/google',\n        passport.authenticate('google', {\n            scope: [ 'profile', 'email' ]\n        }));\n\n    app.get('/auth/google/callback',\n        passport.authenticate('google', { successRedirect: '/' })\n    );\n\n    app.get('/auth/google_user', (req, res) => {\n        res.json({googleUser: req.user});\n    });\n\n    app.get('/auth/logout', function(req, res){\n        req.logout();\n        res.redirect('/');\n    });\n};\n```\n\n## 6. Set cookie\n\n```\nnpm install --save cookie-session\n```\n\nOur *** index.js *** set cookie in the background\n\nWe need to trigger initialize and session here\n\n```javascript\n// init middleware\n// we can use req.body\napp.use(bodyParser.json());\n// enable the cookiesession\napp.use(\n    cookiesSession({\n        maxAge: 24 * 60 * 60 * 1000,\n        keys: [key.CookieSecret]\n    })\n);\napp.use(passport.initialize());\napp.use(passport.session());\nrequire('./routes/oauth/passport');\n```\n\nUntil now, after logging in through google, we can get the current Google user information through /auth/google_user\n\n/ Auth / logout can also be used to clear the current Google user information\n\n## ",
  "5de72e5ca04d34572c33e590": "## 7. proxy\n\n```\nnpm install --save http-proxy-middleware\n```\n\nAt the front desk we need to use proxy to proxy the front port 3000 to 5000 port\n\n```javascript\nconst proxy = require('http-proxy-middleware');\n\nmodule.exports = function(app) {\n    app.use(proxy('/auth/google', { target: 'http://localhost:5000' }));\n    app.use(proxy('/api/*', { target: 'http://localhost:5000' }));\n};\n```\n\n## 8. LoadUser\n\nBefore each loaduser, determine whether there is google user information, and if so, set the current user as google user information.\n\n```javascript\nexport const loadUser = () => async dispatch => {\n    const oauthUser = await axios.get('/auth/google_user');\n    const googleUser = JSON.parse(JSON.stringify(oauthUser.data)).googleUser;\n    if (googleUser){\n        dispatch({\n            type: LOAD_USER,\n            payload: googleUser\n        });\n    }else {\n        if (localStorage.token) {\n            setAuthToken(localStorage.token);\n            try {\n                const res = await axios.get('/api/auth');\n                dispatch({\n                    type: LOAD_USER,\n                    payload: res.data\n                });\n            } catch (err) {\n                console.error(err.message);\n            }\n        }\n    }\n};\n```\n\n## 9. log out\n\nFor insurance, before logging out, first clear the current google user information\n\n```javascript\nexport const logout = () => async dispatch => {\n    await axios.get('/auth/logout');\n    dispatch({\n        type: LOG_OUT\n    });\n};\n```\n\n"
}