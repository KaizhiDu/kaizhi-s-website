{
  "5dd9cdb581ca03e15c7df20c": "# Spring Container\n\n## Inversion of Control\n\nIOC means giving your designed objects to the spring container control instead of the traditional direct control inside your object.\n\n## Dependency Injection\n\nDependency : dependent spring container.\n\nInjection: The spring container injects the required object\n\n# Basic useful annotation\n\n## @Qualifier\n\n@Qualifier: If tow class implements one interface, we need to use qualifier to distinguish them.\n\n```java\n\t@Autowired\n    @Qualifier(\"happyFortune\")\n    private HappyFortune happyFortune;\n\n    @Autowired\n    @Qualifier(\"randomFortune\")\n    private RandomFortune randomFortune;\n```\n\n## @PostConstruct\n\n@PostConstruct: define initial method, only execute once.\n\n```java\n@PostConstruct\n    public void doMyStartupStuff() {\n        System.out.println(\"we call the init method\");\n    }\n```\n\n## @InitBinder\n\n@InitBinder: pre-process all web requests coming into this Controller\n\n```java\n@InitBinder\n    // add an initbinder to convert trim input string\n    public void initBinder(WebDataBinder dataBinder) {\n        StringTrimmerEditor stringTrimmerEditor = new StringTrimmerEditor(true);\n        dataBinder.registerCustomEditor(String.class, stringTrimmerEditor);\n    }\n```\n\n# Validation\n\n## Annotation from spring\n\n```java\n@NotNull(message = \"firstName is required\")\n    @Size(min = 1, message = \"size must >1\")\n    private String firstName;\n```\n\n## Customize annotation\n\n```java\n@CourseCode\n    private String courseCode;\n```\n\n```java\n@Constraint(validatedBy =  CourseCodeConstrainValidator.class)\n//where are we use this annotation\n@Target( { ElementType.METHOD, ElementType.FIELD})\n//Retain this annotation in the java class file\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface CourseCode {\n    // define default course code\n    public String value() default \"LUV\";\n    // define default error message\n    public String message() default \"must start with LUV\";\n    // define default groups\n    public Class<?>[] groups() default {};\n    // define default payload\n    public Class<? extends Payload>[] payload() default {};\n\n}\n```\n\n```java\npublic class CourseCodeConstrainValidator implements ConstraintValidator<CourseCode, String>{\n    private String coursePrefix;\n    @Override\n    public void initialize(CourseCode theCourseCode) {\n        coursePrefix = theCourseCode.value();\n    }\n    @Override\n    //SpringMVC will call is Valid\n    public boolean isValid(String theCode, ConstraintValidatorContext constraintValidatorContext) {\n        boolean result;\n        if (theCode != null) result = theCode.startsWith(coursePrefix);\n        else result = true;\n        return result;\n    }\n}\n```\n\n",
  "5dd9cf56c3cf5851159c5a50": "# Hibernate\n\n## Basic method\n\n***fetch = FetchType.LAZY***   lazy loading, when loading an entity, properties that define lazy loading will not load from the database right away.\n\n***fetch = FetchType.EAGER*** eager loading, when an entity is loaded, the property that defines the rush loading will be loaded immediately from the database.\n\n***cascade = CascadeType.ALL*** refers to a cascading relationship, any operation will affect the corresponding cascading.\n\n## OneToOne\n\n\u200B\tStudent and Course's relationship is OneToOne\n\n```java\n//Student\n@OneToOne(cascade = CascadeType.ALL)\n    //Foreign key name in database\n    @JoinColumn(name = \"course_id\")\n    private Course course;\n```\n\n```java\n//Course\n//mappedBy refers to property course in Student class\n    @OneToOne(mappedBy = \"course\", cascade = CascadeType.ALL)\n    private Student student;\n```\n\n## OneToMany\n\n\u200B\tStudent and hobby's relationship is OneToMany\n\n```java\n//Student\n//we do not want to add the delete rule in the cascade\n    @OneToMany(fetch = FetchType.LAZY, mappedBy = \"student\", cascade = {CascadeType.PERSIST, CascadeType.REFRESH, CascadeType.MERGE, CascadeType.DETACH})\n    private List<Hobby> hobbies;\n```\n\n```java\n//Hobby\n//we do not want to add the delete rule in the cascade\n    @ManyToOne(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST, CascadeType.REFRESH, CascadeType.MERGE, CascadeType.DETACH})\n    @JoinColumn(name = \"student_id\")\n    private Student student;\n```\n\n## ManyToMany\n\n\u200B\tTeacher and course's relationship is ManyToMany\n\n```java\n//Teacher\n@ManyToMany(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST, CascadeType.REFRESH, CascadeType.MERGE, CascadeType.DETACH})\n@JoinTable(\n        name = \"teacher_course\",\n        joinColumns = @JoinColumn(name = \"teacher_id\"),\n        inverseJoinColumns = @JoinColumn(name = \"course_id\")\n)\nprivate List<Course> courses;\n```\n\n```java\n//Course\n@ManyToMany(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST, CascadeType.REFRESH, CascadeType.MERGE, CascadeType.DETACH})\n@JoinTable(\n        name = \"teacher_course\",\n        joinColumns = @JoinColumn(name = \"course_id\"),\n        inverseJoinColumns = @JoinColumn(name = \"teacher_id\")\n)\nprivate List<Teacher> teachers;\n```\n\n",
  "5dd9f5be538cba7031094498": "# Hibernate\n\n## Basic method\n\n***fetch = FetchType.LAZY***   lazy loading, when loading an entity, properties that define lazy loading will not load from the database right away.\n\n***fetch = FetchType.EAGER*** eager loading, when an entity is loaded, the property that defines the rush loading will be loaded immediately from the database.\n\n***cascade = CascadeType.ALL*** refers to a cascading relationship, any operation will affect the corresponding cascading.\n\n## OneToOne\n\n\u200B\tStudent and Course's relationship is OneToOne\n\n```java\n//Student\n@OneToOne(cascade = CascadeType.ALL)\n    //Foreign key name in database\n    @JoinColumn(name = \"course_id\")\n    private Course course;\n```\n\n```java\n//Course\n//mappedBy refers to property course in Student class\n    @OneToOne(mappedBy = \"course\", cascade = CascadeType.ALL)\n    private Student student;\n```\n\n## OneToMany\n\n\u200B\tStudent and hobby's relationship is OneToMany\n\n```java\n//Student\n//we do not want to add the delete rule in the cascade\n    @OneToMany(fetch = FetchType.LAZY, mappedBy = \"student\", cascade = {CascadeType.PERSIST, CascadeType.REFRESH, CascadeType.MERGE, CascadeType.DETACH})\n    private List<Hobby> hobbies;\n```\n\n```java\n//Hobby\n//we do not want to add the delete rule in the cascade\n    @ManyToOne(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST, CascadeType.REFRESH, CascadeType.MERGE, CascadeType.DETACH})\n    @JoinColumn(name = \"student_id\")\n    private Student student;\n```\n\n## ManyToMany\n\n\u200B\tTeacher and course's relationship is ManyToMany\n\n```java\n//Teacher\n@ManyToMany(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST, CascadeType.REFRESH, CascadeType.MERGE, CascadeType.DETACH})\n@JoinTable(\n        name = \"teacher_course\",\n        joinColumns = @JoinColumn(name = \"teacher_id\"),\n        inverseJoinColumns = @JoinColumn(name = \"course_id\")\n)\nprivate List<Course> courses;\n```\n\n```java\n//Course\n@ManyToMany(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST, CascadeType.REFRESH, CascadeType.MERGE, CascadeType.DETACH})\n@JoinTable(\n        name = \"teacher_course\",\n        joinColumns = @JoinColumn(name = \"course_id\"),\n        inverseJoinColumns = @JoinColumn(name = \"teacher_id\")\n)\nprivate List<Teacher> teachers;\n```\n\n\n\n# AOP\n\n## @Pointcut\n\n\u200B\t@PointCut is a set of one or more JoinPoint where an advice should be executed. \n\n```java\n@Pointcut(\"execution(* com.kevin.dao.*.*(..))\")\npublic void daoPackage() {}\n\n@Pointcut(\"execution(* com.kevin.dao.*.get*(..))\")\npublic void getter() {}\n\n@Pointcut(\"execution(* com.kevin.dao.*.set*(..))\")\npublic void setter() {}\n\n@Pointcut(\"daoPackage() && !(getter() || setter())\")\npublic void forDaoPackageNoGetterSetter() {}\n```\n\n## @Before @After  \n\n```java\n@Before(\"com.kevin.aspect.AopExpression.forDaoPackageNoGetterSetter()\")\npublic void beforeDAO(JoinPoint joinPoint) {\n    System.out.println(\"\\n=========>>>>>  Now we run the before\");\n\n    // display the method signature\n    MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();\n\n    System.out.println(\"Method: \" +methodSignature);\n\n    // display method arguments\n    Object[] args = joinPoint.getArgs();\n    for (Object tempArg : args) {\n        if (tempArg instanceof Account) {\n            // downcast and print Account specific stuff\n            Account account = (Account) tempArg;\n            System.out.println(\"account name: \"+account.getName());\n            System.out.println(\"account level: \"+account.getLevel());\n\n        }\n    }\n}\n```\n\n## @AfterReturning\n\n```java\n@AfterReturning(\n        pointcut = \"execution(* com.kevin.dao.AccountDAO.findAccounts(..))\",\n        returning = \"result\")\npublic void afterReturningFindAccountsAdvice(JoinPoint joinPoint, List<Account> result){\n    // print out which method we are advising on\n    String method = joinPoint.getSignature().toShortString();\n    System.out.println(\"\\n =======>>> @AfterReturning \" + method);\n    // print out the result of the method call\n    System.out.println(\"result is: \" + result);\n\n    // let's post-process the data ...Let's modify it\n\n    // convert the account names to uppercase\n\n    convertAccountNamesToUppercase(result);\n\n    System.out.println(\"result(Uppercase) is: \" + result);\n\n}\n\nprivate void convertAccountNamesToUppercase(List<Account> result) {\n        // loop through accounts\n        for (Account account : result ) {\n        // get uppercase version of name\n        String upperName = account.getName().toUpperCase();\n        // update the name on the account\n            account.setName(upperName);\n        }\n    }\n```\n\n## @AfterThrowing\n\n```java\n@AfterThrowing(\n            pointcut = \"execution(* com.kevin.dao.AccountDAO.findAccounts(..))\",\n            throwing = \"e\")\n    public void afterThrowingFindAccountsAdvice(JoinPoint joinPoint, Throwable e) {\n        // print out which method we are advising on\n        String method = joinPoint.getSignature().toShortString();\n        System.out.println(\"\\n =======>>> @AfterThrowing \" + method);\n\n        // log the exception\n        System.out.println(\"\\n Exception is \" + e);\n    }\n```\n\n## @ExceptionHandler\n\nSometime we need to return a JSON data instead of error page, when the error happen. So we need to use the ExceptionHandler.\n\n```JAVA\n// If we want to use the ExceptionHandler, we need to use @ControllerAdvice\n@ControllerAdvice\npublic class StudentRestExceptionHandler {\n\n    // Add an exception handler using @ExceptionHandler\n    @ExceptionHandler\n    public ResponseEntity<StudentErrorResponse> handleException(StudentNotFoundException e) {\n        // create a StudentErrorResponse\n        StudentErrorResponse error = new StudentErrorResponse();\n        error.setStatus(HttpStatus.NOT_FOUND.value());\n        error.setMessage(e.getMessage());\n        error.setTimeStamp(System.currentTimeMillis());\n\n        // return ResponseEntity\n        return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);\n    }\n\n    // add another exception handler\n    @ExceptionHandler\n    public ResponseEntity<StudentErrorResponse> handleException2(Exception e) {\n\n        // create a StudentErrorResponse\n        StudentErrorResponse error = new StudentErrorResponse();\n        error.setStatus(HttpStatus.BAD_REQUEST.value());\n        error.setMessage(e.getMessage());\n        error.setTimeStamp(System.currentTimeMillis());\n\n        // return ResponseEntity\n        return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST);\n    }\n}\n```\n\n```java\n// 404 \npublic class StudentNotFoundException extends RuntimeException{\n\n    public StudentNotFoundException(String message) {\n        super(message);\n    }\n\n    public StudentNotFoundException(String message, Throwable cause) {\n        super(message, cause);\n    }\n\n    public StudentNotFoundException(Throwable cause) {\n        super(cause);\n    }\n}\n```\n\n```java\n// status javaBean\npublic class StudentErrorResponse {\n    private int status;\n    private long timeStamp;\n    private String message;\n}\n```\n\n```java\n@GetMapping(\"/student/{studentId}\")\npublic Student getStudent(@PathVariable int studentId) {\n\n    // check the studentId against list size\n    if ((studentId >= students.size()) || (studentId < 0) ){\n        throw new StudentNotFoundException(\"StudentId is not found \"+studentId);\n    }\n\n    return students.get(studentId);\n}\n```\n\n## @Around\n\n```java\n@Around(\"execution(* com.kevin.service.TrafficFortuneService.getFurtune(..))\")\npublic Object aroundGetFortune(ProceedingJoinPoint proceedingJoinPoint) throws Throwable{\n\n    // print out method we are advising on\n    String method = proceedingJoinPoint.getSignature().toShortString();\n    //System.out.println(\"\\n =======>>> @Around \" + method);\n\n    logger.info(\"\\n =======>>> @Around \" + method);\n\n    // get begin timestamp\n    long begin = System.currentTimeMillis();\n\n    // now, let's execute the method\n    Object result = null;\n\n    try {\n        result = proceedingJoinPoint.proceed();\n    }\n    catch (Exception e) {\n        // log the exception\n        logger.warning(e.getMessage());\n        // give user a message\n        result = \"It is an exception, but do not worry, we knew it\";\n    }\n```\n\n",
  "5dd9f67a4e96a55e951b463e": "# Interceptor \n\nWe need to compare the token in the cookie with the token in the current user. If we don't use Interceptor, we need to compare the logic on each page, so we use Interceptor to solve this problem.\n\n1. We need to define a Service to implement the HandlerInterceptor interface, then write the logic code in preHandle\n\n```java\n@Service\npublic class SessionInterceptor implements HandlerInterceptor {\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Override\n    public boolean preHandle(HttpServletRequest req, HttpServletResponse response, Object handler) throws Exception {\n        Cookie[] cookies = req.getCookies();\n        if (cookies!= null && cookies.length != 0) {\n            for (Cookie cookie : cookies ) {\n                if (cookie.getName().equals(\"token\")) {\n                    String token = cookie.getValue();\n                    QueryWrapper<User> wrapper = new QueryWrapper<>();\n                    wrapper.eq(\"token\", token);\n                    User user = userMapper.selectOne(wrapper);\n                    if (user != null) {\n                        req.getSession().setAttribute(\"user\", user);\n                    }\n                    break;\n                }\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {  }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {   }\n}\n```\n\n2. We also need to define a Webconfig to configure the Interceptor. Below we define a WebConfig to implement WebMvcConfigurer\n\n```java\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n\t// Dependency injection SessionInterceptor\n    @Autowired\n    private SessionInterceptor sessionInterceptor;\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        // All interceptors execute this interceptor\n        registry.addInterceptor(sessionInterceptor).addPathPatterns(\"/**\");\n    }\n}\n```\n\n# Error Handler\n\nWe expect that when the input url is wrong, it will jump to the corresponding error page. Here you need to use the Error Handler.\n\n## Basic usage\n\nSpring provides a way to capture 4xx and 5xx errors.\n\nFirst we define a Controller to implement ErrorController. Below we can capture is4xxClientError() and is5xxServerError() according to HttpStatus.\n\n```java\n@Controller\n@RequestMapping(\"${server.error.path:${error.path:/error}}\")\npublic class CustomizeErrorController implements ErrorController {\n    @Override\n    public String getErrorPath() {\n        return \"error\";\n    }\n\n    @RequestMapping(produces = MediaType.TEXT_HTML_VALUE)\n    ModelAndView errorHtml(HttpServletRequest request, Model model) {\n        HttpStatus status = getStatus(request);\n\n        if (status.is4xxClientError()) {\n            model.addAttribute(\"message\", \"Wrong request url, please check\");\n        }\n//        if (status.is5xxServerError()) {\n//            model.addAttribute(\"message\", \"unknown error, please contact laodu\");\n//        }\n        return new ModelAndView(\"error\");\n    }\n\n    private HttpStatus getStatus(HttpServletRequest request) {\n        Integer statusCode = (Integer) request.getAttribute(\"javax.servlet.error.status_code\");\n        if (statusCode == null) {\n            return HttpStatus.INTERNAL_SERVER_ERROR;\n        }\n        return HttpStatus.valueOf(statusCode);\n    }\n\n}\n\n```\n\n## Customize Error Handler\n\nIf the user is empty, or the problem is empty, we can only know that it is a 5xx problem, but we cannot return specific error information according to the specific problem. So we need costomize our own Error Handler\n\n1. First we have to define CustomizeErrorCode\n\n   Define the CustomizeErrorCode of the enum type, and set all the error prompts, and inherit the getMessage method of the interface\n\n   ```java\n   public interface ICustomizeErrorCode {\n       public String getMessage();\n   }\n   ```\n\n   ```java\n   public enum CustomizeErrorCode implements ICustomizeErrorCode{\n   \n       QUESTION_NOT_FOUND(\"The question you find is not exist\");\n   \n       private String message;\n   \n       @Override\n       public String getMessage() {\n           return message;\n       }\n   \n       CustomizeErrorCode(String message) {\n           this.message = message;\n       }\n   }\n   ```\n\n2. Then set the CustomizeException\n\n   CustomizeException to inherit RuntimeException, to monitor the exceptions that may occur while the program is running, and to construct a constructor that accepts the error in CustomizeErrorCode and assigns it to the message.\n\n   ```java\n   public class CustomizeException extends RuntimeException {\n   \n       private String message;\n   \n       public CustomizeException(ICustomizeErrorCode errorCode) {\n           this.message = errorCode.getMessage();\n       }\n   \n       public CustomizeException(String message) {\n           this.message = message;\n       }\n   \n       @Override\n       public String getMessage() {\n           return message;\n       }\n   }\n   ```\n\n3. Create a ControllerAdvice to handle the information that needs to be returned to the page when the exception occurs.\n\n   ```java\n   @ControllerAdvice(basePackageClasses = ExceptionHandlerAdvice.class)\n   public class ExceptionHandlerAdvice {\n   \n       @ExceptionHandler(Exception.class)\n       ModelAndView handle(HttpServletRequest request, Throwable e, Model model) {\n           //If the message above CustomizeException is different from the default message, return the custom message.\n           if (e instanceof CustomizeException){\n               model.addAttribute(\"message\", e.getMessage());\n   \n           }else{\n               model.addAttribute(\"message\", \"unknown error, please contact laodu\");\n           }\n   \t\t// Return to the error page\n           return new ModelAndView(\"error\");\n       }\n   }\n   ```\n\n   Add the following code wherever there is a problem with QUESTION_NOT_FOUND. That ‘s all\n\n   ```java\n   if (question == null) {\n       //Throws a custom exception, the enumeration code for the exception is QUESTION_NOT_FOUND\n               throw new CustomizeException(CustomizeErrorCode.QUESTION_NOT_FOUND);\n           }\n   ```\n\n   \n\n"
}